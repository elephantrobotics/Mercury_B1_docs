{"./":{"url":"./","title":"Introduction","keywords":"","body":"Mercury_B1_docs "},"1-ProductIntroduction/":{"url":"1-ProductIntroduction/","title":"1 产品介绍","keywords":"","body":""},"1-ProductIntroduction/1.1-DesignPhilosophy.html":{"url":"1-ProductIntroduction/1.1-DesignPhilosophy.html","title":"1.1 设计理念","keywords":"","body":"1.1 设计理念 Mercury B1双臂半人形机器人共有17个自由度。 它配备两个A1七轴机械臂，具有单臂独立操作和双臂协同操作的能力。 头部配备9英寸高清液晶触摸屏，支持多点控制和用户定制表情显示。 它还配备了NVIDIA Jetson Xavier边缘计算核心作为主控模块。 高达21TOPS的AI性能结合集成的3D摄像头，可以完成2D/3D机器视觉引导、抓取和VR远程操作。 "},"1-ProductIntroduction/1.2-ApplicationScenario.html":{"url":"1-ProductIntroduction/1.2-ApplicationScenario.html","title":"1.2 适合用户","keywords":"","body":"1.2 应用场景 1.2.1 科研场景 一站式科研具身智能人形机器人 —— 水星Mercury B1。 得益于自研控制算法与自研模组的应用，B1 可用于双臂协同控制、双臂运动规划、人形具身智能应用等多个方向研究与应用，是人形机器人应用研究的首选机型。 1.2.2 教育场景 机器人教育教学套装，可搭配2D或3D视觉模组，可以实现人形具身智能教育中图像识别、模型训练、机器人控制、运动规划、机器人空间标定、视觉与机器人手眼标定等多个学科不同领域的知识学习。 1.2.3 服务场景 水星Mercury系列的强悍性能及内在表现，搭配优雅的外观设计，使得水星Mercury机器人不仅可以用于教育、科研场景，也可以用于商业服务场景，通过不同的末端配件，搭配各种日常家具家电，机器人可以服务于实际的公司展示、商业展会、行业交流等应用环境，展现机器人服务员的炫酷应用。 1.2.4 娱乐场景 搭配自定义的末端执行器，进行模拟人类的动作开发，水星Mercury机器人可以实现类人动作应用，进行个人应用的创意开发。 1.2.5 VR/Aloha遥操作场景 搭配VR/Aloha等设备，实现远程操控的机器人应用 "},"2-ProductFeature/":{"url":"2-ProductFeature/","title":"2 产品特点","keywords":"","body":""},"2-ProductFeature/2.1-MachineSpecification.html":{"url":"2-ProductFeature/2.1-MachineSpecification.html","title":"2.1 功能参数","keywords":"","body":"产品规格 1 机器参数 指标 参数 中文名称 水星B1双臂机器人 型号 水星B1 产品尺寸 200*192.5*537mm 自由度 17 最大工作半径 8小时 最大负载 1KG 机械臂重复精度 ±0.05 mm 净重 8KG 工作电压 24V 重复精度 +-0.05mm 减速机构 谐波减速机 关节制动式 电磁摩擦片式 CPU 6核Arm v8.2 64位CPU GPU 384 核 Volta™ GPU 算力 21 TOPS 材质 碳纤维、铝合金、工程塑料 3D相机 Obi Nakakotsu Deeyea 麦克风阵列 线性4麦克风，5米180°拾音 IO 24V 6 输入，6 输出 屏幕 9寸触摸屏 通讯方式 CAN总线/WIFI/网口/蓝牙/USB/串口 2 软件基本功能支持 功能/开发环境 用途 自由行动 支持 关节运动 支持 笛卡尔运动 支持 轨迹记录 支持 无线控制 支持 紧急停止 支持 Windows 支持 Linux 支持 MAC 支持 ROS 1 支持 Python 支持 C++ 支持 C# 支持 JavaScript 支持 myblockly 支持 Arduino 支持 mystudio 支持 串口控制协议 支持 TCP/IP 支持 MODBUS 支持 ← 上一页| 下一页 → "},"2-ProductFeature/2.2-ControlCoreParameter.html":{"url":"2-ProductFeature/2.2-ControlCoreParameter.html","title":"2.2 控制器参数","keywords":"","body":"控制核心参数 1 主控制器 指标 参数 主控 Jetson Xavier 主模型 Jetson Xavier NX 中央处理器 6 核 NVIDIA Carmel ARM®v8.2 64 位 CPU 6MB L2 + 4MB L3 图形处理器 具有 48 个 Tensor 核心的 384 核 NVIDIA Volta™ GPU 算力 21 TOPS 存储 16 GB eMMC 5.1 CSI 摄像机 2 个 CSI 摄像机 网络 10/100/1000 BASE-T 以太网 USB端口 1 个 USB 3.2 2.0 (10 Gbps) 2 个 USB 2.0 端口 其他输入/输出 2个UART串口 2 主控制器 指标 参数 主控 左臂主控 主模型 ESP32 核心参数 240MHz 双核。 600 DMIPS，520KB SRAM。 Wi-Fi、双模蓝牙 辅助控制Flash 4MB LED显示屏 5X5 RGB 3 主控制器 指标 参数 主控 右臂主控 主模型 ESP32 核心参数 240MHz 双核。 600 DMIPS，520KB SRAM。 Wi-Fi、双模蓝牙 辅助控制Flash 4MB LED显示屏 5X5 RGB ←上一页| 下一页 → "},"2-ProductFeature/2.3-MechanicalStructureParameter.html":{"url":"2-ProductFeature/2.3-MechanicalStructureParameter.html","title":"2.3 结构参数","keywords":"","body":"结构尺寸参数 本章的距离和角度单位为毫米。 1 产品尺寸和工作空间 选择机器人安装位置时，重要的是要考虑机器人正上方和正下方的圆柱空间，并尽可能避免将工具移向圆柱空间。 因为这会导致工具运动缓慢时关节旋转过快，导致机器人效率低下且风险评估困难。 2 底座安装尺寸 3 双臂端法兰尺寸 图 2.3.4 端部尺寸 ←上一页| 下一页 → "},"2-ProductFeature/2.4-ElectricalCharacteristicParameter.html":{"url":"2-ProductFeature/2.4-ElectricalCharacteristicParameter.html","title":"2.4 电子参数","keywords":"","body":"电气特性参数 1 Dock接口概述 图1 基础接口图 1.1 Dock 接口说明 编号 接口 定义 特点 注意 1 急停接口 停止 急停回路接口 2 DC/IO接口 24V 直流24V DC24V输出 OUT1 数字输出信号1~6 仅在 PNP 模式下输出 OUT2 OUT3 OUT4 OUT5 OUT6 GND GND 3 DC/IO接口 GND GND IN6 数字输入信号1~6 仅进入NPN模式 IN5 IN4 IN3 IN2 IN1 24V 直流24V DC24V输入 4 以太网端口 以太网 以太网通讯接口 5 电源输入接口 DC24V输入 DC24V输入 4 以太网端口 以太网 以太网通讯接口 5 电源输入接口 DC24V输入 DC24V输入 6 开关 电源开关 控制输入电源的通断 带灯（灯亮） 7 R-USB 右臂 USB 用USB连接外置摄像头 8 L-USB 左臂 USB 用USB连接外置摄像头 9 USB3.0 USB3.0*2 可连接外部设备或U盘 "},"3-UserNotes/":{"url":"3-UserNotes/","title":"3 用户须知","keywords":"","body":""},"3-UserNotes/3.1-SafetyInstruction.html":{"url":"3-UserNotes/3.1-SafetyInstruction.html","title":"3.1 安全守则","keywords":"","body":"安全须知 1 概要 本章详细介绍了对大象机器人进行安装、维护和修理工作的人员的一般安全信息。在搬运、安装、使用前，请仔细阅读并理解本章内容及注意事项。 2 危险识别 协作机器人的安全性基于机器人的正确配置和使用。此外，即使遵守了所有安全说明，操作员也可能会造成伤害或损坏。因此，了解机器人使用的安全风险以预防它们非常重要。 表1-1至表3列出了机器人使用过程中可能出现的常见安全风险： 表1-1 风险等级 安全风险 1 因机器人操作不当造成的人身伤害或机器人损坏。 2 如果机器人没有按照要求固定，例如螺丝缺失或螺丝不紧，或者底座的锁定能力不足以支撑机器人高速移动，机器人就会翻倒，导致人身伤害或机器人损坏。 3 由于安全功能配置不正确或缺乏安全防护工具，导致机器人安全功能未能发挥作用。 表1-2 安全风险提示 1 调试程序时，不要停留在机器人的运动范围内。安全配置不当可能无法避免碰撞，造成人身伤害。 2 机器人与其他设备之间的连接可能会带来新的危险，需要进行全面的风险评估。 3 小心工作环境中的其他设备或机器人末端执行器等尖锐表面造成的划伤和刺伤。 4 机器人是精密机器；踩到它们可能会造成损坏。运输过程中放置​​不当可能会导致振动，影响内部零件并造成损坏。因此，请确保在所有情况下的稳定性和机械结构完整性。 5 如果在机器人断电前（夹紧不牢固时）未移除被夹物，可能会导致末端执行器损坏或被夹物因断电而掉落受伤等危险。 6 存在机器人意外移动的风险。在任何情况下都不要站在机器人的任何轴下！ 7 与普通机械设备相比，机器人具有更多的自由度和更大的运动范围。未能保持在运动范围内可能会导致意外碰撞。 表1-3 可能导致触电的安全隐患 1 使用非原装电缆可能会产生未知的危险。 2 电气设备接触液体可能引起漏电危险。 3 电气连接错误可能会导致触电。 4 更换前请务必关闭控制器及相关设备的电源并拔下电源插头。如果带电进行操作，可能会导致触电或故障。 3 安全注意事项 使用机械手时应遵守以下安全规则： 机械臂属于带电设备。非专业人员不得随意改变电路，否则可能对设备或人体造成损害。 操作机械臂时，请遵守当地法律法规。本手册中描述的安全注意事项和危险、警告和注意事项仅是对当地安全法规的补充。 请在规定的环境下使用机械臂。超过机械臂的规格和负载条件会缩短产品的使用寿命，甚至损坏设备。 无论如何，安装、操作和维护 myCobot 手臂的人员必须接受有关安全预防措施以及操作和维护机器人的正确方法的严格培训。 无论如何，请勿在潮湿环境中长时间使用本产品。本产品为精密电子元件，长期处于潮湿环境中会损坏设备。 无论如何，请勿在潮湿环境中长时间使用本产品。本产品为精密电子元件，长期处于潮湿环境中会损坏设备。 高腐蚀性清洁不适合清洁机械臂，阳极氧化部件不适合浸泡清洁。 不知不觉中，请勿在未安装底座的情况下使用设备，以免损坏设备或发生事故，应在没有障碍物的固定环境中使用设备。 请勿使用其他电源适配器供电。如果因使用非标准适配器而导致设备损坏，则不包含售后服务。 请勿拆卸、拆解或拧开机械手的螺钉或外壳。若自行拆卸，则不提供保修服务。 未经专业培训的人员不得擅自修理故障产品和拆卸机械臂。如果产品出现故障，请及时联系myCobot技术支持工程师。 如果产品被丢弃，请遵守相关法律，妥善处理工业废物，保护环境。 孩子在某个时刻使用设备，迫使某人监视该过程并在完成后将其关闭。 机器人运动时，请勿将手伸入机器人手臂的运动范围内，以免发生碰撞。 严禁更改、拆除或修改机械手及相关设备的铭牌、说明、图标和标志。 请小心搬运和安装。按照包装箱上的说明轻轻放好机器人，并按照箭头方向正确放置。否则，机器可能会损坏。 请勿从 Atom 终端刻录其他产品驱动程序，或使用非官方建议刻录固件。如果因用户烧录其他固件而导致设备损坏，则不属于售后服务范围。 电源规格：使用官方电源 USB Type-C 使用规范：不要连接到电源板 如果您对本手册内容有任何疑问或建议，请登录大象机器人官方网站并提交相关信息： https://www.elephantrobotics.com 请不要将机械臂用于以下用途： 生命攸关的应用中的医疗保健成本。 购买公共汽车可能会导致环境爆炸。 四旬斋直接使用，无需进行风险评估。 使用低级别安全功能的成本。 Lo-fi不符合机器人使用性能参数。 4 免责声明 请在使用产品前仔细阅读并理解以下免责声明： 安全使用： 本产品专为特定应用场景而设计。确保在使用过程中遵循所有安全准则和操作手册。用户应接受有关产品使用的适当培训，并了解并遵守所有相关的安全法规。 责任限制： 对于因使用或误用产品或与产品相关的任何事项而导致的任何直接、间接、偶然、特殊或后果性损害，制造商概不负责。本免责声明不涵盖或排除法律不允许排除的责任。 技术支持： 请在安装和使用过程中仔细阅读产品文档，必要时寻求制造商的技术支持。有关技术支持问题，请参阅厂家提供的官方文档或联系相关支持渠道。 软件更新： 制造商可能会提供产品固件或软件的更新。用户应定期检查并应用这些更新，以确保产品性能和安全性。 定期维护： 用户应按照制造商提供的定期维护指南检查和维护产品。定期维护和检查有助于确保产品的长期性能。 定制和修改： 未经制造商明确许可，不得定制、修改或变更产品。任何未经授权的修改都可能导致产品保修失效，并可能对安全和性能产生不可预测的影响。 法律合规性： 用户应确保其使用符合所有适用的法律和法规。在某些地区，产品的使用可能受到特定法规的限制。 使用 Mercury A1 七轴协作机器人，即表示您同意并接受这些免责声明。制造商保留更改产品规格、功能和免责声明的权利，恕不另行通知。 ← 上一节 | 下一章 → "},"3-UserNotes/3.2-TransportandStorage.html":{"url":"3-UserNotes/3.2-TransportandStorage.html","title":"3.2 运输与储存","keywords":"","body":"运输与保存 1 物流运输要求 温度 0°C~50°C 相对湿度 20%~70% 运输时的方向 机器人头部朝上，双臂垂下 运输时的外部条件 外部使用木架固定，防止挤压 2 设备储藏 温度 0°C~50°C 相对湿度 20%~70% 运输时的方向 机器人头部朝上，双臂垂下 叠压要求 不可叠压 储藏环境 室内 其他环境要求 - 远离灰尘、油烟、盐分、铁屑等。 - 远离易燃性、腐蚀性液体与气体。- 不得与水接触。- 不传递冲击与振动等。- 远离强电磁干扰源。 ← 上一节 | 下一章 → "},"3-UserNotes/3.3-MaintenanceandCare.html":{"url":"3-UserNotes/3.3-MaintenanceandCare.html","title":"3.3 维护和保养","keywords":"","body":"维护和保养   作为一家机器人制造商，我们重视确保客户能够正确、安全地维护和升级他们的机器人设备。为此，我们提供以下详细的维护和保养指南，包括常见维护项目及维修或升级硬件的部分，请您认真阅读。 1 常见维护项目及推荐周期 维护项目 描述 推荐周期 视觉检查 检查机器人有无明显的损坏、异物堆积或磨损 日常 结构清洁 使用干净、干燥的布料清洁机器人结构部件，避免水分和侵蚀性清洁剂 日常 紧固件检查 检查并紧固所有螺栓和连接件 日常 润滑 对关节和移动部件进行润滑，使用制造商推荐的润滑油 每3个月 电缆和接线检查 检查电缆和接线，确保无损坏或磨损 每月 电气连接检查 确保所有电气连接牢固，无腐蚀或损坏 每月 软件更新 检查并更新控制软件和应用程序 每次有更新时 软件数据备份 定期备份关键软件配置和数据 每季度 固件更新 定期检查并更新固件，以获取最新的功能和安全补丁 每次有更新时 传感器和器件检查 检查传感器和其他关键器件，确保正常工作 每月 紧急停止功能测试 定期测试紧急停止功能，确保其可靠性 每月 环境条件监控 监控工作环境的温度、湿度、灰尘等，确保符合机器人的操作规格。 持续监控 安全配置复查 定期检查和确认机器人的安全配置，如限速和工作范围设定 每月 预防性维护计划执行 按制造商的维护计划执行定期检查和维护 按制造商指南 2 独立更改机器人硬件的指南   我们理解客户可能会有自行升级或维修机器人硬件的需求。在进行任何升级操作之前，请务必详细阅读产品的相关参数，并与我们的官方人员确认是否被允许进行此类操作。未经官方允许的操作可能导致产品故障，且不在保修范围内。 物料要求   官方制造或推荐的物料：所有维修和升级所需的配件和组件必须是由我们官方制造或明确推荐的。这包括但不限于电子组件、传感器、电机、连接件和任何其他可更换部件。   物料获取：客户可通过我们的官方渠道购买所需的维修和升级物料。这确保了配件的质量和兼容性。 维修或升级流程   客户自行维修：客户应负责完成维修工作。我们将提供详细的维修指导和手册，以指导客户完成维修步骤。   遵循官方指导：维修操作应严格遵循我们提供的官方指导。任何偏离官方指导的操作都可能导致设备损坏。 责任和保修政策 责任划分：   制造商：提供维修和升级的官方指导、官方制造或推荐的物料，并处理由制造缺陷导致的问题。   客户：负责按照官方指导完成维修，使用官方配件。 保修政策：   保修有效：只有当维修操作完全遵循我们的指导，且使用官方配件时，保修才有效。   保修无效：若客户未按官方指导操作，或使用非官方配件进行维修或升级，导致的任何损坏都将不在保修范围内。 注意事项   安全第一：在进行任何维修或升级操作前，请确保遵循所有安全指南，包括断电和使用适当的防护装备。   技术支持：如在维修过程中遇到问题，建议停止操作并联系我们的技术支持团队寻求帮助。   我们强烈建议客户严格遵循这些指南，以确保机器人设备的安全、有效运行。不当的维修操作可能导致设备损坏并影响保修状态。如需进一步的指导或支持，请及时联系我们的专业技术团队。 ← 上一节 | 下一章 → "},"3-UserNotes/3.4-FAQsandSolutions.html":{"url":"3-UserNotes/3.4-FAQsandSolutions.html","title":"3.4 常见问题解答","keywords":"","body":"常见问题   在这一部分中，列出了一些常见的驱动程序相关问题、软件相关问题和硬件相关问题。 1 如何优雅地提问 2 驱动器相关 3 软件问题 4 硬件问题 如果您有购买意向或任何参数问题，请发送电子邮件至此邮箱。 邮箱 : \"sales@elephantrobotics.com\" 如果列出的问题不能帮您解决，您有更多售后问题，请发送邮件至此邮箱。 邮箱 : \"support@elephantrobotics.com\" ← 上一节 | 下一章 → "},"3-UserNotes/IssueFAQ/how_to_ask.html":{"url":"3-UserNotes/IssueFAQ/how_to_ask.html","title":"1 如何优雅地提问","keywords":"","body":"如何优雅地提出问题 1 在各个地方提出问题时，您会发现几种现象： 提出问题后没有答案。 回答这个问题花了很长时间。 另一方总是忽略我，什么也不做。2 在提出问题之前，请确保您已经研究了文档。 在此过程中将解决许多问题。一开始，请勿在QQ组，论坛，问题或电子邮件中提出问题。一开始在文档中解释的许多问题可能不会在社区及时回答。为了节省每个人的时间，为了获得更好的社区环境，每个人都可以更好地共同成长，请互相了解。 3 提问时，尽量做到以下几点，这样可以大大增加快速解决问题的机会： 弄清楚发生了什么以及我做了什么，包括： 我想达到什么效果和功能？ 为了达到这种效果，我该怎么做，详细的过程是什么？ 在实施过程中，发生了什么错误，出现了什么现象（例如，报错是什么，完整错误内容是什么？ 我是否仔细阅读了错误消息，错误消息中是否有任何错误原因和解决方案的指示？ 根据这些错误信息，请仔细思考，我能解决问题吗？ 我可以通过搜索文档、问题和使用搜索引擎来找到问题的解决方案吗？ 4 如果自己实在解决不了问题，需要找人帮忙，需要考虑： 问谁，在哪里问，谁有更好的机会回答我的问题？那么实时呢？ 我应该给他什么数据和现象，让他愿意帮我快速解决问题？ 提供我的目的（让回答者知道你在做什么）。 提供完整的实施过程和过程中发生的现象（让回答者按照你的流程再做一遍，即问题复发）。 给出错误的位置，指出现象或结果与您预期的不同之处！（让回答者知道，哪里没有达到预期）。 对于出现的错误信息，需要完整，截图越多，日志多一点，不要吝啬拍一张小照片，或者给出一部分日志（因为回答者可能已经很久没有这样做了，他们忘记了一些细节，需要依靠截图和完整的日志来快速回忆。并且根据详细的日志，他们可以快速定位问题所在）。 如何以更诚恳的态度提问，即使我什么都不懂，大家也愿意回答。 5 问题模板 尽量优雅地提问，不添加多余的情态助词，抱怨词汇，考虑每一个单词和标点符号，从回答者的角度思考问题，以及如何让回答者帮我快速解决问题。单词太少会使问题难以描述，单词太多会使回答者不耐烦。 6 标题 无论在哪里提问（包括QQ群），为您的问题准备一个大约30字的标题，阐明问题的中心思想，包括： 要明确区分问题的类型，是要问的问题，还是提交bug，还是经验分享等等。让应答者在充满文本的屏幕上立即找到您要做的事情。 一句话阐明问题的核心，如运行相机示例程序，报错复位失败，可能是硬件问题。 所以合成后的标题可以是这样的： [Mycobot 问题] 运行相机示例程序，报告错误重置失败。会不会是硬件问题？ 尽量不要出现在这样的标题中： 为什么我的电路板又不工作了？ 为什么我的代码不起作用？ 为什么我的屏幕是黑色的？ [Mycobot 问题] 我收到了开发板，为什么开发板屏幕是红色的，而且有一小行文字？ 我运行了一个程序，但出了点问题。 7 内容 如果被问到一个问题，首先站在回答者的角度： 首先，我需要知道对方想做什么，要达到的目标是什么。 为了实现这一目标，他提到了哪些步骤？ 实际上，使用了哪些具体步骤，然后在哪个步骤发生了问题，以便我可以尝试根据他的步骤重现该现象。如果这个问题看起来很难解决，并且没有重现它的步骤，那么重现可能需要很多时间，所以让我们把它放在一边，先解决其他问题。 出现的具体问题是什么，如果他只是陈述问题，我怎么知道他出了什么问题，也许是身体不适？所以这很重要，我需要请他解释问题的现象，并指出与预期有什么不同，否则我必须猜测比较和预期有什么区别，解决问题的时间增加了。 如果有问题，我可能需要他的日志文件，这样我就可以根据日志分析源代码，否则可能很难解决问题，那么这个问题可以稍后查看。 总之，您可以提出以下问题： 详细说明你的目标，你想做什么，以及现象应该是什么样子。 有没有我参考的文档、代码或教程？ 如何重现错误：如何详细操作，详细编写每个步骤，直到问题发生。 详细说明错误发生时发生了什么，以及它与预期有何不同，并且需要证明问题确实发生了。 附上日志文件，以及截图，甚至视频，日志和截图一定要完整，不能只是一小部分，回答者可能会发现一些你从你的完整日志和截图中没有注意到的问题，这一点很重要。 另外，粘贴代码时要注意格式。粘贴后不要乱七八糟地显示，看不见。尝试复制它并直接运行它。 *最后，你需要感谢回答问题的社区朋友。 ← 上一页 | 下一页 → "},"3-UserNotes/IssueFAQ/driver.html":{"url":"3-UserNotes/IssueFAQ/driver.html","title":"2 驱动器相关","keywords":"","body":"驱动器相关 1 关于python 问： send_base_coords（[x，y，z，rx，ry，rz]， speed） 此 API 中的参数是什么意思？rx、ry 和 rz 对应于欧拉角什么？欧拉角的旋转顺序是什么？每个参数的取值范围是多少？ 答：前面数组中的参数是 mercury X1 末端的坐标，speed 是速度。rx、ry 和 rz 应对应 RPY，即分别对应滚动、俯仰和偏航。欧拉角的阶数是 zyx，zyx 是它自己的坐标。x、y、z的取值范围。为-350~350，-350~350，-41~523.9（取值范围未定义，如果超过该范围，将返回逆运动学无解提示），rx、ry、rz的取值范围为-180~180。 问：不同版本的机械臂的 python api 是否相同？ 答：API 是一样的。 2 关于ROS 问：您能提供 rviz 模型的文件和编程示例吗？ 答：它可以在我们的 github 上找到。 “https://github.com/elephantrobotics/mercury_ros2” 问：为什么使用 ROS 启动 rviz 模型文件时，报错权限“/dev/ttyUSB0”？ 答：这是因为没有给出串口权限。您应该在终端中键入 sudo chmod 777 端口名称。 例如：sudo chmod 777 /dev/ttyUSB0 问：为什么在运行 ROS 的滑块控件和模型遵循命令时，错误 _init_() takes exactly 2 arguments (3 given)？ 答：pymycobot 库未安装和启动。 问：使用 ROS 时，为什么打开 rviz 模型后 mercury_B1 角度与模型角度不一致？ 答：很有可能mercury_B1的零位没有校准，mercury_B1的零位需要校准。 ← 上一页 | 下一页 → "},"3-UserNotes/IssueFAQ/software.html":{"url":"3-UserNotes/IssueFAQ/software.html","title":"3 软件问题","keywords":"","body":"软件问题 关于ROS1 问:终端切换到~/catkin_ws/src，使用git安装更新mercury_ros时，目标路径“mercury_ros”已经存在。原因是什么? 答:这意味着在~/catkin_ws/src中已经有一个“mercury_ros”包了。需要提前删除，然后重新执行git操作。 问: rosrun运行时，终端错误提示“could not open port /dev/ttyUSB0: Permission: '/dev/ttyUSB0'”。为什么? 答:串口权限不足。在终端输入“sudo chmod 777 /dev/ttyUSB0”，授予权限。 问:为什么ROS程序不能在VSCode中运行? 答:由于VSCode终端无法加载到ROS环境中，需要在系统终端中运行。 问: rosrun运行时，终端提示“无法注册主节点[http://localhost:11311]:主节点可能尚未运行”。我会继续努力的。”原因是什么? 答:运行ROS程序前，需要打开ROS节点，在终端中输入“roscore”。 问: rosrun运行时，终端错误提示“could not open port /dev/ ttyusb0: No such file or directory: '/dev/ttyUSB1'”。为什么? 答:串口错误。需要确认当前机械臂的实际串口。可以通过ls /dev/tty*查看。 问:在Ubuntu18.04中，' catkin_make '构建代码失败，终端提示' Project 'cv_bridge'指定'/usr/include/opencv'作为包含目录，没有找到。和其他错误信息 答:配置文件中的OpenCV路径与系统实际路径不匹配。你需要使用sudo命令修改配置文件(路径为“/opt/ros/melodic/share/cv_bridge/cmake/cv_bridgeConfig.cmake”)。系统的实际OpenCV路径位于“/usr/include/”路径下。 问:只需克隆mercury_ros包，然后直接运行rosrun程序。出现诸如“package”mercury_ros“not found”之类的错误或诸如无法找到文件之类的错误? 答:新克隆的mercury_ros需要构建ROS环境编译的代码。终端输入 bash cd ~/catkin_ws/ catkin_make source devel/ setup.bash 关于机械臂控制 问:给机械臂发送角度或坐标机械臂没有运动 答：使用get_angles()读取机械臂的角度，若角度返回为空，则检查机械臂是否上电，使用power_on()对机械臂进行上电使能；检查端口号是否使用正确。 若有角度，查看角度是否超出运动范围见表1，如果超出范围，使用release_all_servos()放松所有关节（注意关节放松后会下坠，需要接住），对齐1~5、7关节零刻度线，6关节与零刻度线90度垂直。再使用focus_all_servos()锁定关节，再使用set_servo_calibration(1)~set_servo_calibration(7)依次校准各关节零点，再使用get_angles()读取当前关节角度，如返回数据为[0, 0, 0, 0, 0, 90, 0]则为校准成功，否则重复之前的校准步骤。 表1-1 各关节角度可运动范围 关节 范围 J1 -175 ~ +175 J2 -65 ~ +115 J3 -175 ~ +175 J4 -180 ~ +10 J5 -175 ~ +175 J6 -20 ~ + 173 J7 -180 ~ +180 问:摄像头无法打开 答：打开本地相机查看是否可以切换到左右臂摄像头，如有某个摄像头无法查看，则重新拔插USB口或者更换USB口。 若可以切换到左右摄像头，检查摄像头端口是否发生变化(在重启后，端口可能发生变化) 问:自适应夹爪无法控制 答：查看自适应夹爪的电源指示灯，正常时指示灯应为常亮状态，若指示灯出现闪烁情况，请重新拔插夹爪与机械臂的连接线，指示灯恢复常亮状态则正常。 若指示灯为常亮状态仍无法控制，使用set_gripper_mode(0)更改夹爪使用模式。 "},"3-UserNotes/IssueFAQ/hardware.html":{"url":"3-UserNotes/IssueFAQ/hardware.html","title":"4 硬件问题","keywords":"","body":"硬件问题 1 关于结构 问:Atom在机械臂中的作用是什么? 答: Atom主要控制机械臂的运动学算法，包括正逆运动学、解选择、加减速、速度同步、多功率插补、坐标转换等。与atom相关的程序还不是开源的。 问:使用过程中电机自动切断电源。为什么? 答:电机长时间使用有过热保护。这种现象属于正常现象，几分钟后可以继续使用。 2 关于参数 问:机械臂的速度单位是多少? 答:运行速度为180度/秒。 问:自适应夹持器可以不完全关闭吗? 答:下巴之间会有一定的间隙，它们并不是完全闭合的。您可以通过增加它们之间的间隔的厚度来调整它。 问:机械臂末端USB摄像头如何固定? 答:需要用法兰固定，可以单独购买。 "},"4-FirstInstallAndUse/":{"url":"4-FirstInstallAndUse/","title":"4 首次安装及使用","keywords":"","body":""},"4-FirstInstallAndUse/4-FirstInstallAndUse.html":{"url":"4-FirstInstallAndUse/4-FirstInstallAndUse.html","title":"4.1 产品标准表","keywords":"","body":"首次安装和使用 谢谢您选择我们的产品 在开始之前，我们要衷心感谢您选择我们的产品。我们致力于为您提供出色的用户体验。 首次使用和问题处理 本章将在收到产品后详细介绍该产品的初始使用，并提供有关解决问题的相关信息，以确保您在使用过程中不必担心。 跳到每个部分 4.1产品标准清单 4.2 产品开箱指南 4.3 开机检测指南 ← 上一章 | 下一章r → "},"4-FirstInstallAndUse/4.2-ProductUnboxingGuide.html":{"url":"4-FirstInstallAndUse/4.2-ProductUnboxingGuide.html","title":"4.2 产品开箱指南","keywords":"","body":"产品开箱指南 1 产品开箱图形指南 为什么您需要按照以下步骤移出产品 在本节中，我们强烈建议按照指定的步骤移出产品。这不仅有助于确保产品在运输过程中不会损坏，还可以将意外故障的风险降至最低。请仔细阅读以下图形指南，以确保您的产品在开箱过程中是安全的。 1 检查箱体是否损坏。如有损坏，请及时与您所在地区的物流公司和供应商联系。 2 打开包装盒，取出使用说明、海绵包装盖、mercury_B1机器人、配套电源、发货清单。 3 在进行下一个步骤之前，请确保每一步都已完成，以防止不必要的损坏或遗漏。 注意: 取下产品后，请仔细检查每件物品的外观。请将箱子里的实际项目与项目清单核对一下。 ←上一页 |下一页→ "},"4-FirstInstallAndUse/4.3-Power-onTestGuide.html":{"url":"4-FirstInstallAndUse/4.3-Power-onTestGuide.html","title":"4.3 上电测试指南","keywords":"","body":"启动检测指南 外部电缆连接 操作前请仔细阅读 章节安全说明 ，确保操作安全。同时将电源适配器与底座连接。 电源状态显示 确认电源适配器已连接，按下电源开关启动按钮(圆形)。 基本功能检测 操作时请参考5.1-4机器人信息章节进行指导。在继续操作之前，请确保按照上述电气连接说明进行操作，并确认设备已安全安装。没有正确连接线缆或固定设备，可能会导致事故。谢谢你的合作。 ←上一页 |下一章→ "},"6-SDKDevelopment/":{"url":"6-SDKDevelopment/","title":"5 SDK 开发","keywords":"","body":""},"6-SDKDevelopment/6.1-ApplicationBasePython.html":{"url":"6-SDKDevelopment/6.1-ApplicationBasePython.html","title":"5.1 Python","keywords":"","body":""},"10-ApplicationBasePython/10.1-EnvironmentConfiguration.html":{"url":"10-ApplicationBasePython/10.1-EnvironmentConfiguration.html","title":"1 环境搭建","keywords":"","body":"环境配置 pymycobot是Elephant Robot开发的Python库，用于机器人控制。 Linux 系统出厂时默认安装了Python 3.8.10，并且已经安装了pymycobot控制库，用户无需自行安装。 pymycobot 安装 通过终端输入命令即可安装pymycobot pip install pymycobot pymycobot 卸载 您可以通过终端输入命令来卸载pymycobot pip uninstall pymycobot pymycobot 更新 您可以通过终端输入命令来更新pymycobot pip install pymycobot -U 窗口 1.1 安装Python 注意： 安装前，请检查PC的操作系统。 在“我的电脑”图标上按右键，然后选择“属性”。安装相应的Python。 前往http://www.python.org/download/下载Python。 点击“下载”，然后开始下载。 勾选“将 Python 3.10 添加到 PATH”。 单击“立即安装”，然后开始安装。 下载并安装完成。 1.2 运行Python 打开命令提示符窗口（Win+R，输入“cmd”并按“Enter”）。 输入“Python”。 安装成功： 屏幕上出现此指示意味着 Python 已成功安装。 提示符“>>>”表示Python交互环境。 如果输入一段Python代码，立即得到执行结果。 错误报告： 如果输入了错误的指令，例如“pythonn”，系统可能会报告错误。 注意： 一般情况下，该错误是由于环境配置不足造成的。 参考1.3 环境配置解决问题。 1.3 环境变量配置 Windows 遵循 Path 环境变量设置的路径来搜索 python.exe 。 否则会报错。 如果安装时没有勾选“Add Python 3.9 to PATH”，则需要手动将python.exe所在路径添加到环境变量中或者重新下载python。 请记住勾选“将 Python 3.9 添加到 PATH”。 按照以下步骤手动将 python 添加到环境变量中。 右键单击“我的电脑”图标 --> 属性 -> 高级系统设置 -> 环境变量 环境变量包括用户变量和系统变量。 对于用户变量，用户可以通过“cmd”命令使用自己下载的程序。 将目标程序的绝对路径写入用户变量中。 配置完成后，打开命令提示符窗口（Win+R；输入“cmd”并按“Enter”），然后输入“Python”。 2 PyCharm的安装 PyCharm 是一款功能强大、具有跨平台性质的 Python 编辑器。 请按照以下步骤下载并安装 PyCharm。 前往 PyCharm 下载 PyCharm。 2.1 下载与安装 官网查看： 建议安装免费版本。 点击“下一步”： 根据您的需要选择选项，然后选择“下一步”： 点击“安装”： 安装： 点击“完成” 2.2 创建新项目 点击“+新建项目”： --> Interpreter 用于解释Python程序。 选择“添加解释器”->“新建”以添加基本解释器。 Location是指保存python文件的位置。 选择一个文件来放置您的程序。 点击“创建”，会出现一个示例： --> 右键单击红色箭头所指的选项，然后创建一个新的 python 文件。 --> 键入新文件的名称。 --> 3 准备工作 pymycobot 安装。 通过终端（Win+R）“cmd”命令输入“pip install pymycobot --upgrade --user”。 pip install pymycobot --upgrade --user 源码安装。 打开终端（Win+R，输入 cmd ），然后输入以下命令进行安装。 git clone https://github.com/elephantrobotics/pymycobot.git #中填写你的安装地址，不要选择当前默认路径。 cd /pymycobot #进入下载包的pymycobot文件夹。 #根据您的python版本运行以下命令之一。 ＃ install python2 setup.py install ＃ or python3 setup.py install 更新pymycobot pip install pymycobot --upgrade 注意： 如果代码下方没有出现红色波浪线，则说明pymycobot安装成功。 如果出现红色波浪线，请前往地址 https://github.com/elephantrobotics/pymycobot 手动下载 pymycobot 并将其放入 python 库中。 Python的基本使用 from pymycobot import Mercury ml = Mercury('/dev/left_arm') mr = Mercury('/dev/right_arm') ml.power_on() mr.power_on() print(ml.get_angles()) print(mr.get_angles()) ← 系统介绍 | Python API → "},"10-ApplicationBasePython/10.2-ApplicationBasePython.html":{"url":"10-ApplicationBasePython/10.2-ApplicationBasePython.html","title":"2 API简介","keywords":"","body":"6.1 Python API 6.1.2 API使用说明 API（ApplicationProgrammingInterface），也称为应用程序编程接口函数，是预定义的函数。 使用以下功能接口时，请在开始时输入以下代码导入我们的API库，否则无法成功运行： ＃ 例子 from pymycobot import Mercury ml = Mercury('/dev/left_arm') mr = Mercury('/dev/right_arm') ml.power_on() mr.power_on() print(ml.get_angles()) print(mr.get_angles()) 1.系统状态 get_system_version() 功能： 获取系统版本 返回值： 系统版本 get_robot_type() 功能： 获取机器人id 返回值： 定义规则：实际机器型号。 例如水星A1型号为4500 get_atom_version() 功能： 获取最终版本号 返回值： 结束参数(float) get_robot_status() 功能： 上位机错误安全状态 返回值： 0 - 正常。 其他 - 机器人触发碰撞检测 2.总体状况 power_on() 功能： atom开放通讯（默认开放） 注意： 执行关机或按紧急停止后，需要 7 秒才能上电并恢复供电 返回值： 1 - 开机完成。 0 - 开机失败 power_off() 功能： 机械臂断电 返回值： 1 - 开机完成。 0 - 开机失败 is_power_on() 功能： 判断机械臂是否通电 返回值： 1: 开机 0：关闭电源 -1: 错误 release_all_servos() 功能： 释放所有机械臂 注意：关节禁用后，需在1秒内启用才能控制 参数：data（可选）：放松关节的方式。 默认为阻尼模式，如果提供了'data'参数，则可以指定为非阻尼模式（1-Undamping）。 返回值： 1 - 发布完成。 0 - 释放失败 focus_all_servos() 功能： 打开机器人扭矩输出 返回值： 1: 完成 0：失败 -1: 错误 3.MDI模式及操作 get_angles() 功能： 获取所有关节的度数 返回值：list所有级别的浮点列表 get_angle() 功能： 获取单关节角度 参数： joint_id (int): 1 ~ 7 返回值： 关节对应的角度数组 send_angle(id, degree, speed) 功能： 向机器人手臂发送一度关节 参数： id：关节id(genre.Angle)，范围 int 1-7 degree: 角度值(float) 手臂关节活动范围 | 关节id | 角度 | | ---- | ---- | | 1 | -178 ~ 178 | | 2 | -74 ~ 130 | | 3 | -178 ~ 178 | | 4 | -180 ~ 10 | | 5 | -178 ~ 178 | | 6 | -20 ~ 273 | | 7 | -180 ~ 180 | 身体关节的活动范围。 第 11 关节是下巴摄像头。 第 12 关节是颈部。 第13关节是腰椎关节 | 关节id | 角度 | | ---- | ---- | | 11 | -60 ~ 0 | | 12 | -138 ~ 188 | | 13 | -118 ~ 118 | speed：机械臂运动速度和幅度 1~100 send_angles(angles, speed) 功能： 将所有角度发送到机械臂的所有关节 参数： angles：角度值列表(List[float])，长度 7 速度: (int) 1 ~ 100 get_coords() 功能： 从基于底座的坐标系获取机器人手臂坐标 返回值： 坐标的浮点列表：[x, y, z, rx, ry, rz] send_coord(id, coord, speed) 功能： 发送一个坐标到机械臂 参数： id：发送一个坐标到机械臂，1-6对应[x, y, z, rx, ry, rz] coord: 坐标值(float) | 坐标id | 范围 | | ---- | ---- | | 1 | -466 ~ 466 | | 2 | -466 ~ 466 | | 3 | -240 ~ 531 | | 4 | -180 ~ 180 | | 5 | -180 ~ 180 | | 6 | -180 ~ 180 | speed: (int) 1-100 send_coords(coords, speed, mode) 功能：：发送整体坐标和姿态，使机械臂头部从原点移动到您指定的点 参数： coords: ： 坐标值列表 [x,y,z,rx,ry,rz],length6 速度(int): 1 ~ 100 pause() 功能： 控制指令暂停核心并停止所有运动指令 is_paused() 功能： 检查程序是否暂停了移动命令 返回值： 1 - 暂停 0 - 未暂停 -1 - 错误 resume() 功能： 恢复机器人运动并完成之前的命令 stop() 功能： 停止机器人的所有动作 返回值： 1 - 停止 0 - 不停止 -1 - 错误 is_in_position(data, flag) 功能 ：判断是否在位。 参数： data：提供一组数据，可以是角度或坐标值。 如果输入角度长度范围为7，如果输入坐标值长度范围为6 标志数据类型（值范围0或1） 0：角度 1：坐标 返回值： 1 - 正确 0 - 假 -1 - 错误 is_moving() 功能： 判断机器人是否在移动 返回值： 1移动 0 不动 -1 错误 4. JOG 模式及操作 jog_angle(joint_id, direction, speed) 功能： 点动控制角度 参数： joint_id：代表机械臂的关节，用关节ID表示，范围为1到7 direction(int)：控制机械臂运动方向，输入0为负值运动，输入1为正值运动 速度：1 ~ 100 jog_coord(coord_id, direction, speed) 功能： 点动控制坐标。 参数： coord_id: (int) 机械臂坐标范围：1~6 direction:(int) 控制机械臂运动方向，0 - 负值运动，1 - 正值运动 速度：1 ~ 100 jog_increment_angle(joint_id, increment, speed) 功能： 单关节角度增量控制 参数： joint_id：1-7 increment：根据当前位置角度增量移动 速度：1 ~ 100 jog_increment_coord(coord_id, increment, speed) 功能： 单关节角度增量控制 参数： joint_id：轴ID 1 - 6。 increment：基于当前位置坐标的增量运动 速度：1 ~ 100 5.坐标控制姿态偏差角 get_solution_angles() 功能： 获取零空间偏转角度值 返回值：零空间偏转角度值 set_solution_angles(angle, speed) 功能： 获取零空间偏转角度值 参数： angle : 输入关节1的角度范围，角度范围-90到90 速度：1 - 100。 6.联合软件限位操作 get_joint_min_angle(joint_id) 功能： 读取最小关节角度 参数： joint_id：输入关节 ID（范围 1-7） 返回值：float角度值 get_joint_max_angle(joint_id) 功能： 读取最大关节角度 参数： joint_id：输入关节 ID（范围 1-7） 返回值： float 角度值 set_joint_min(id, angle) 功能： 设置最小关节角度限制 参数： id ：输入关节 ID（范围 1-7） angle：参考send_angle()接口中对应关节的限制信息，不得小于最小值 set_joint_max(id, angle) 功能： 设置最小关节角度限制 参数： id ：输入关节 ID（范围 1-7） angle：参考send_angle()接口中对应关节的限制信息，不得大于最大值 7.关节电机控制 is_servo_enable(servo_id) 功能： 检测关节连接状态 参数：舵机id1-7 返回值： 1: 连接成功 0：未连接 -1: 错误 is_all_servo_enable() 功能： 检测所有关节连接的状态 返回值： 1: 连接成功 0：未连接 -1: 错误 set_servo_calibration(servo_id) 功能： 校准关节执行器当前位置为角度零点 参数： servo_id：1 - 7 release_servo(servo_id) 功能： 设置指定关节扭矩输出关闭 参数： servo_id: 1 ~ 7 返回值： 1: 释放成功 0: 释放失败 -1: 错误 focus_servo(servo_id) 功能：设置指定关节扭矩输出开启 参数：servo_id：1 ~ 7 返回值： 1：聚焦成功 0：焦点失败 -1: 错误 set_break（joint_id, value） 功能： 设置断点 参数： joint_id：int。 关节 ID 1 - 7 值：整数。 0 - 禁用，1 - 启用 返回值： 0：失败； 1：成功 get_servo_speeds() 功能：获取所有关节的运动速度 返回值： 单位step/s get_servo_currents() 功能：获取所有关节的运动电流 返回值： 0 ~ 5000 mA get_servo_status() 功能：获取所有关节的运动状态 返回值：值为0表示没有错误 servo_restore(joint_id) 功能：清除关节异常 参数： joint_id：int。 关节 ID 1 - 7 8.机械臂端IO控制 set_digital_output(pin_no, pin_signal) 功能： 设置IO状态 参数 pin_no (int): PIN 码 pin_signal (int): 0 / 1 get_digital_input(pin_no) 功能： 读取IO状态 参数：pin_no (int) 返回值：信号 9. 机械臂末端夹具控制 set_gripper_state(flag, speed, _type_1=None) 功能：自适应夹具启用 参数： flag (int): 0 - 打开 1 - 关闭，254 - 释放 速度（整数）：1 ~ 100 _type_1 (int): 1：自适应夹具（默认状态为 1） 2 : 一只灵活的手，有 5 个手指 3：平行夹具 4：柔性夹具 set_gripper_value(gripper_value, speed, gripper_type=None) 功能：设置夹具值 参数： gripper_value (int): 0 ~ 100 speed（int）：1 ~ 100 gripper_type (int): 1：自适应夹具（默认状态为 1） 2 : 一只灵活的手，有 5 个手指 3：平行夹具 4：柔性夹具 set_gripper_calibration() 功能：将夹具的当前位置设置为零 set_gripper_enabled(value) 功能：自适应夹具启用设置 参数： value 1：启用 0：释放 set_gripper_mode(mode) 功能：设置夹具模式 参数： 值： 0：透传模式 1：正常模式 get_gripper_mode() 功能：获取抓手模式 返回值： 0：透传模式 1：正常模式 10.机械臂末端的按钮功能 is_btn_clicked() 功能：获取机械臂末端按钮的状态 返回值： 0：没有点击 1：点击 set_color(r, g, b) 功能：设置机械臂末端灯颜色 参数： r（int）：0 ~ 255 g（int）：0 ~ 255 b（int）：0 ~ 255 11.拖动教学 drag_teach_save() 功能： 开始录制并拖动教学点。 注意：为了显示最佳运动效果，录制时间不应超过90秒 drag_teach_pause() 功能： 暂停采样 drag_teach_execute() 功能： 开始拖动示教点，仅执行一次。 drag_teach_clean() 功能： 清除样品。 12.笛卡尔空间坐标参数设置 set_tool_reference(coords) 功能： 设置工具坐标系。 参数：coords: (list) [x, y, z, rx, ry, rz]。 返回值： NULL get_tool_reference(coords) 功能： 获取工具坐标系。 返回值： oords: (list) [x, y, z, rx, ry, rz] set_world_reference(coords) 功能： 设置世界坐标系。 参数：coords: (list) [x, y, z, rx, ry, rz]。 返回值： NULL get_world_reference() 功能： 获取世界坐标系。 返回值： list [x, y, z, rx, ry, rz]。 set_reference_frame(rftype) 功能： 设置基础坐标系。 参数：rftype: 0 - 基础 1 - 工具。 get_reference_frame() 功能： 设置基础坐标系。 返回值： 0 - 基数 1 - 工具。 set_movement_type(move_type) 功能： 设置运动类型。 参数： move_type：1 - movel，0 - moveJ。 get_movement_type() 功能： 获取运动类型。 返回值： 1 - 移动 0 - moveJ set_end_type(end) 功能： 获取结束坐标系 参数： end (int)：0 - 法兰，1 - 工具 get_end_type() 功能： 获取结束坐标系 返回值： 0 - 法兰 1 - 工具 13.圆周运动 write_move_c(transpoint, endpoint, speed) 功能：圆弧轨迹运动 参数： transpoint(list)：经过点坐标的圆弧 endpoint(list)：圆弧端点坐标 速度(int)： 1 ~ 100 14.设置底层IO输入/输出状态 set_basic_output(pin_no, pin_signal) 功能：设置基本IO输出 参数： pin_no (int) Pin 端口号，范围 1 ~ 6 pin_signal (int)：0 - 低。 1 - 高 get_basic_input(pin_no) 功能：设置基本IO输出 参数： pin_no (int) Pin 端口号，范围 1 ~ 6 pin_signal (int)：0 - 低。 1 - 高 tool_serial_restore() 功能：485恢复出厂设置 tool_serial_ready() 功能： 设置485通讯 返回值： 0：未设置 1：设置完成 tool_serial_available() 功能： 设置485通讯 返回值： 0-正常 1-机器人触发碰撞检测 tool_serial_read_data() 功能： 读取固定长度数据。 读取之前，先读取缓冲区长度。 读取后数据将被清除 参数： data_len (int)：要读取的字节数，范围1 ~ 45 返回值： 0：未设置 1：设置完成 tool_serial_write_data() 功能： 结束485发送数据，数据长度范围为1 ~ 45字节 返回值： 0-正常 1-机器人触发碰撞检测 tool_serial_flush() 功能： 清除485缓冲区 返回值： 0-正常 1-机器人触发碰撞检测 tool_serial_peek() 功能： 查看缓冲区中的第一条数据，数据不会被清除 返回值： 1字节数据 tool_serial_set_baud(baud) 功能： 设置485波特率，默认115200 参数：波特率（int）：波特率 返回值： NULL tool_serial_set_timeout(max_time) 功能： 设置 485 超时时间（以毫秒为单位），默认 30ms 参数 max_time: (int): 超时 返回值： NULL 6.1.2 基础控制接口 要调用下面的Python接口，需要先启动ROS服务器。 roslaunch Turn_on_mercury_robot navigation.launch 接下来，打开另一个终端并输入以下命令。 cd ~/mercury_x1_ros/src/turn_on_mercury_robot/scripts/ python cobotx_socket_server_json.py go_straight(speed=0.25, exercise_duration=5) 功能： 控制底座向前移动 参数： 速度：移动速度。 单位：米/秒 exercise_duration: 运动持续时间。 go_back(speed=0.25, exercise_duration=5) 功能： 控制底座向后移动 参数： 速度：移动速度。 单位：米/秒 exercise_duration: 运动持续时间。 turn_left(speed=0.25, exercise_duration=5) 功能： 控制底座左转运动 参数： 速度：移动速度。 单位：米/秒 exercise_duration: 运动持续时间。 turn_right(speed=0.25, exercise_duration=5) 功能： 控制底座右转运动 参数： 速度：移动速度。 单位：米/秒 exercise_duration: 运动持续时间。 stop() 功能： 控制底座停止当前运动。 init_position(position_x, position_y, orientation_z, orientation_w, covariance) 功能： 设置导航起始位置。 参数*： position_x： position_y： orientation_z: orientation_w: covariance： goto_position(position_x, position_y, orientation_z, orientation_w, covariance) 功能： 导航到目标点。 参数*： position_x: position_y: orientation_z: orientation_w: covariance: cancel_navigation() 功能： 取消导航。 get_software_version() 功能： 获取基础服务器版本号。 get_base_ros_version() 功能： 获取基础ROS项目版本号。 get_battery_state() 功能： 获取电池电量。 "},"10-ApplicationBasePython/10.3-PythonDemo.html":{"url":"10-ApplicationBasePython/10.3-PythonDemo.html","title":"3 python 案例","keywords":"","body":"案例 1 将末端灯的颜色设置为蓝色 from pymycobot import Mercury ml = Mercury(\"/dev/ttyTHS0\") mr = Mercury(\"/dev/ttyACM0\") # 机器人上电 ml.power_on() mr.power_on() ml.set_color(0,0,255) mr.set_color(0,0,255) 案例 2 角度控制 from pymycobot import Mercury import time ml = Mercury(\"/dev/ttyTHS0\") mr = Mercury(\"/dev/ttyACM0\") # 机器人上电 ml.power_on() mr.power_on() # 单角度控制 ml.send_angle(1, 90, 40) mr.send_angle(1, 90, 40) time.sleep(3) ml.send_angle(1, 0, 40) mr.send_angle(1, 0, 40) time.sleep(3) # 所有角度控制 ml.send_angles([0, 0, 90, 0, 0, 90, 0], 40) mr.send_angles([0, 0, 90, 0, 0, 90, 0], 40) time.sleep(3) ml.send_angles([0, 0, 0, 0, 0, 90, 0], 40) mr.send_angles([0, 0, 0, 0, 0, 90, 0], 40) "},"10-ApplicationBasePython/10.4-Drag_teach.html":{"url":"10-ApplicationBasePython/10.4-Drag_teach.html","title":"4 拖动示教","keywords":"","body":"拖动教学 拖动教学保存() 开始录制并拖动教学点。 注意：为了显示最佳运动效果，录制时间不应超过90秒 拖动教学暂停() 暂停采样。暂停采样并再次启用机械臂 拖动教学执行() 开始拖动示教点，仅执行一次。 ＃ 案例 from pymycobot import Mercury import time ml = Mercury(\"/dev/ttyTHS0\") mr = Mercury(\"/dev/ttyACM0\") ml.power_on() mr.power_on() # 左臂开始轨迹记录 ml.drag_teach_save() # 记录时长为10秒 time.sleep(10) # 停止记录 ml.drag_teach_pause() time.sleep(1) # 开始执行记录的运动轨迹，仅执行一次 ml.drag_teach_execute() "},"11-ApplicationBaseROS/11.1-ROS1/":{"url":"11-ApplicationBaseROS/11.1-ROS1/","title":"5.2 机器人操作系统 1 (ROS1) ","keywords":"","body":"ROS ROS是用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象、低级设备控制、常用功能的实现、进程之间的消息传递以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。 ROS 运行时的“graph”是一种基于ROS通信基础结构的松耦合点对点进程网络。ROS实现了几种不同的通信方式，包括基于同步RPC样式通信的服务（services）机制，基于异步流媒体数据的话题（topics）机制以及用于数据存储的参数服务器。 ROS并不是一个实时的框架，但ROS可以嵌入实时程序。Willow Garage的PR2机器人使用了一种叫做 pr2_etherCAT 的系统来实时发送或接收 ROS 消息。ROS还可以与Orocos 实时工具包无缝集成。 ROS 图标 ： 1 ros 的设计目标和特点 很多人都在问“ROS与其它机器人软件平台有什么不同？”这是一个很难解答的问题。因为ROS不是一个集成了大多数功能或特征的框架。事实上，ROS 的主要目标是为机器人研究和开发提供代码复用的支持。ROS是一个分布式的进程（也就是节点）框架，这些进程被封装在易于被分享和发布的程序包和功能包集中。ROS也支持一种类似于代码储存库的联合系统，这个系统也可以实现工程的协作及发布。这个设计可以使一个工程的开发和实现从文件系统到用户接口完全独立决策（不受ROS限制）。同时，所有的工程都可以被ROS的基础工具整合在一起。 为了支持共享和协作这一主要目标，ROS 框架还有其他几个特点： 精简：ROS尽可能设计的精简，以便为ROS编写的代码可以与其他机器人软件框架一起使用。由此得出的必然结论是ROS可以轻松集成在其它机器人软件平台：ROS已经可以与OpenRAVE，Orocos和Player集成。 ROS不敏感库：ROS的首选开发模型都是用不依赖ROS的干净的库函数编写而成。 语言独立：ROS框架可以简单地使用任何的现代编程语言实现。ros已经实现了Python版本，C++版本和 Lisp版本。同时也拥有Java 和 Lua版本的实验库。 松耦合:ROS中功能模块封装于独立的功能包或元功能包，便于分享，功能包内的模块以节点为单位运行，以ROS标准的IO作为接口，开发者不需要关注模块内部实现，只要了解接口规则就能实现复用,实现了模块间点对点的松耦合连接 方便测试：ROS内建一个了叫做rostest的单元/集成测试框架，可以轻松安装或卸载测试模块。 可扩展：ROS可以适用于大型运行时系统和大型开发进程。 免费且开源：开发者众多，功能包多 2 为什么使用ROS 通过ROS，我们能够在虚拟环境中实现对机械臂的仿真控制。 我们将通过 rviz 平台实现对机械臂的可视化，并使用多种方式对我们的机械臂进行操作；通过 moveit 平台进行机械臂行动路径的规划和执行，达到自由控制机械臂的效果。 我们将在接下来的章节中学习如何通过ros中的平台对我们产品的控制进行控制。 MoveIt MoveIt 是目前针对机械臂移动操作的最先进的软件，已在 100 多个机器人上使用。它综合了运动规划、控制、3D 感知、运控学、控制和导航的最新成果，提供了开发先进机器人应用的易用平台，为工业、商业和研发等领域的机器人新产品的设计和集成体用评估提供了一个集成化软件平台。 MoveIt 图标 : 1 简介 MoveIt 是ROS中的一个集成开发平台，由多种用于操纵机械臂的功能包组成，包括：运动规划、操作、控制、逆运动学、3D感知和碰撞检测等。 下图所示为 Moveit 提供的主要节点 move_group 的高层结构，它像一个组合器：把所有单独的组件集成在一起，提供一系列的 actions 和 services 供用户使用。 2 用户界面 用户可以通过三种方式访问move_group提供的操作和服务： 在C++ ： 使用move_group_interface包可以方便实用move_group。 在 Python ： 使用moveit_commander包。 通过 GUI ： 使用 Motion——commander 的 Rviz（ROS可视化工具）。 move_group可以使用ROS参数服务器进行配置，从中还可以获取机器人的URDF和SRDF。 3 配置 move_group是一个 ROS 节点。它使用ROS参数服务器来获取三种信息： URDF - move_group在ROS参数服务器上查找robot_description参数，以获取机器人的URDF。 SRDF - move_group在 ROS 参数服务器上查找robot_description_semantic参数，以获取机器人的 SRDF。SRDF 通常由用户使用 MoveIt 设置助理创建。 MoveIt 配置 - move_group将在 ROS 参数服务器上查找特定于 MoveIt 的其他配置，包括关节限制、运动学、运动规划、感知和其他信息。这些组件的配置文件由MoveIt设置助手自动生成，并存储在机器人的相应MoveIt配置包的配置目录中。配置助手的使用请参考：MoveIt Setup Assistant ← 上一节 | 下一页 → "},"11-ApplicationBaseROS/11.1-ROS1/11.1.1-EnvironmentBuilding.html":{"url":"11-ApplicationBaseROS/11.1-ROS1/11.1.1-EnvironmentBuilding.html","title":"1 环境搭建","keywords":"","body":"Linux系统环境搭建 系统出厂自带Ubuntu（V-20.04）系统，内置开发环境，无需搭建和管理，更新mercury_ros包即可。 mercury_ros是大象机器人推出的适用于其Mercury B1系列机械臂的ROS1包。 ROS1项目地址: http://github.com/elephantrobotics/mercury_ros 机械臂API驱动库地址: https://github.com/elephantrobotics/pymycobot 1 更新 mercury_ros 包 为了保证用户能及时使用最新的官方包，可以通过文件管理器进入/home/er/文件夹，打开ROS1环境终端，然后运行命令更新： # 克隆github上的代码 cd ~/catkin_ws/src git clone https://github.com/elephantrobotics/mercury_ros.git # 在决定是否执行此命令之前，请查看下面的注意部分 cd ~/catkin_ws # 回到工作区 catkin_make # 在工作区中构建代码 source devel/setup.bash # 添加环境变量 注意: 如果在/home/er/catkin_ws/src（相当于~/catkin_ws/src）目录下已经存在mercury_ros文件夹，则需要先删除原来的mercury_ros，然后再执行上述命令。 其中，目录路径中的er为系统的用户名。 如有不一致，请修改。 至此ROS1环境搭建完成，您可以学习 ROS的基础知识 或者 ROS使用案例。 ← 上一页 | 下一页 → "},"11-ApplicationBaseROS/11.1-ROS1/11.1.2-ROS_Basics.html":{"url":"11-ApplicationBaseROS/11.1-ROS1/11.1.2-ROS_Basics.html","title":"2 ROS 基础","keywords":"","body":"1 ROS工程结构 1.1 catkin工作空间 Catkin工作空间是创建、修改、编译catkin软件包的目录。catkin的工作空间，直观的形容就是一个仓库，里面装载着ROS的各种项目工程，便于系统组织管理调用。 创建工作空间： mkdir -p ~/catkin_ws/src # 创建文件夹 cd ~/catkin_ws/src # 进入文件夹 catkin_init_workspace # 把当前目录初始化为一个ROS工作空间 cd .. # 返回上级目录 catkin_make # 构建工作区中的代码。 catkin的结构十分清晰，它包括了src、build、devel三个路径，在有些编译选项下也可能包括其他。但这三个文件夹是catkin编译系统默认的。它们的具体作用如下： src/: ROS的catkin软件包（源代码包） build/: catkin（CMake）的缓存信息和中间文件 devel/: 生成的目标文件（包括头文件，动态链接库，静态链接库，可执行文件等）、环境变量 一个简单的工作空间如下所示： workspace_folder/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n 1.2 ROS软件包 Package不仅是Linux上的软件包，也是catkin编译得基本单元，我们使用 catkin_make 编译的对象就是每 个ROS的package。 +-- PACKAGE +-- CMakeLists.txt +-- package.xml +-- src/ +-- include/ +-- scripts/ +-- msg/ +-- srv/ +-- urdf/ +-- launch/ CMakeLists.txt: 定义package的包名、依赖、源文件、目标文件等编译规则，是package不可少的成 分 package.xml: 描述package的包名、版本号、作者、依赖等信息，是package不可少的成分 src/: 存放ROS的源代码，包括C++的源码和(.cpp)以及Python的module(.py) include/: 存放C++源码对应的头文件 scripts/: 存放可执行脚本，例如shell脚本(.sh)、Python脚本(.py) msg/: 存放自定义格式的消息(.msg) srv/: 存放自定义格式的服务(.srv) urdf/: 存放机器人的模型描述(.urdf或.xacro)、3D模型文件(.sda, .stl, .dae等) launch/: 存放launch文件(.launch或.xml) 创建自己的软件包: 指令格式： catkin_create_pkg命令会要求你输入package_name，如有需要还可以在后面添加一些需要依赖的其它软件包： catkin_create_pkg [depend1] [depend2] [depend3] 例如： catkin_create_pkg beginner_tutorials std_msgs rospy roscpp 2 ROS通信架构 2.1 Master与node 1 Master 节点管理器，每个node启动前要向master注册，管理node之间的通信。 2 roscore 启动master，也会启动rosout（日志管理）和parameter server（参数管理器） 3 node ROS的进程、pkg里可执行文件运行的实例。 $rosrun [pkg_name] [node_name] #启动 $rosnode list #列出当前运行的node信息 $rosnode info [node_name] #显示某个node的详细信息 $rosnode kill [node_name] #结束某个node 4 launch 启动master和多个node。 $roslaunch [pkg_name] [file_name.launch] 2.2 Service 与 Topic 我们提供一些 service 和 topic， 用以和 mycobot 交互。 1 Service 命令行中输入: # 显示活动的服务信息 rosservice list 相关的命令与说明： 命令 详细说明 rosservice list 显示活动的服务信息 rosservice info [服务名称] 显示指定服务的信息 rosservice type [服务名称] 显示服务类型 rosservice find [服务类型] 查找指定服务类型的服务 rosservice uri [服务名称] 显示ROSRPC URI服务 rosservice args [服务名称] 显示服务参数 rosservice call [服务名称] [参数] 用输入的参数请求服务 2 Topic 命令行中输入 # 显示活动的服务信息 rostopic list 相关的命令与说明： 命令 详细说明 rostopic list 显示活动的话题目录 rostopic echo [话题名称] 实时显示指定话题的消息内容 rostopic find [类型名称] 显示使用指定类型的消息的话题 rostopic type [话题名称] 显示指定话题的消息类型 rostopic bw [话题名称] 显示指定话题的消息带宽（bandwidth） rostopic hz [话题名称] 显示指定话题的消息数据发布周期 rostopic info [话题名称] 显示指定话题的信息 rostopic pub [话题名称] [消息类型] [参数] 用指定的话题名称发布消息 service与topic的区别： service topic 同步性 异步 同步 通信模型 发布/订阅 服务器/客户端 底层协议 ROSTCP/ROSUDP ROSTCP/ROSUDP 反馈机制 无 有 缓冲区 有 无 实时性 弱 强 节点关系 多对多 一对多 适用场景 数据传输 逻辑处理 您可以前往service和topic深入了解这两项功能的使用 2.3 msg和srv简介 msg：msg文件是描述ROS消息字段的简单文本文件。它们用于为不同语言（c++或者python等）的消息生成源代码。 srv：srv文件用来描述服务。它由两部分组成：请求（request）和响应（response）。 msg文件存储在包的msg目录中，而srv文件存储在srv目录中。 1 rosmsg rosmsg是用于显示有关 ROS消息类型的 信息的命令行工具。 rosmsg 演示： rosmsg show # 显示消息描述 rosmsg info # 显示消息信息 rosmsg list # 列出所有消息 rosmsg md5 # 显示 md5 加密后的消息 rosmsg package # 显示某个功能包下的所有消息 rosmsg packages # 列出包含消息的功能包 rosmsg list 会列出当前 ROS 中的所有 msg rosmsg packages 列出包含消息的所有包 rosmsg package 列出某个包下的所有msg //rosmsg package # 包名 rosmsg package turtlesim rosmsg show 显示消息描述 //rosmsg show # 消息名称 rosmsg show turtlesim/Pose # 结果: float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity rosmsg info 作用与 rosmsg show 一样 rosmsg md5 一种校验算法，保证数据传输的一致性 2 rossrv rossrv是用于显示有关ROS服务类型的信息的命令行工具，与 rosmsg 使用语法高度雷同。 rossrv show # 显示服务消息详情 rossrv info # 显示服务消息相关信息 rossrv list # 列出所有服务信息 rossrv md5 # 显示 md5 加密后的服务消息 rossrv package # 显示某个包下所有服务消息 rossrv packages # 显示包含服务消息的所有包 rossrv list 会列出当前 ROS 中的所有 srv 消息 rossrv packages 列出包含服务消息的所有包 rossrv package 列出某个包下的所有msg //rossrv package # 包名 rossrv package turtlesim rossrv show 显示消息描述 //rossrv show # 消息名称 rossrv show turtlesim/Spawn # 结果: float32 x float32 y float32 theta string name --- string name rossrv info 作用与 rossrv show 一致 rossrv md5 对 service 数据使用 md5 校验(加密) 3 URDF介绍 Unified Robot Description Format，统一机器人描述格式，简称为URDF。ROS中的urdf功能包包含一个URDF的C++解析器，URDF文件使用XML格式描述机器人模型。 URDF 不能单独使用，需要结合 Rviz 或 Gazebo，URDF 只是一个文件，需要在 Rviz 或 Gazebo 中渲染成图形化的机器人模型。 3.1 urdf文件描述 代码示例： 本处只截取部分代码进行展示： ...... 可以看出，urdf文件并不复杂，主要是由link和joint两个部分不断重复而成。 3.2 link部分 link元素描述具有惯性、可视特征和碰撞属性的刚体 3.2.1 属性 name： 用来描述链接本身的名称 3.2.2 元素 (可选) 连杆的惯性特性 (可选，defaults to identity if not specified) 定义相对于连杆坐标系的惯性参考系的参考坐标，该坐标必需定义在连杆重心处，其坐标轴可与惯性主轴不平行。 xyz (可选，默认为零向量) 表示 x , y , z x,y,zx,y,z 方向的偏置，单位为米。 rpy(可选: defaults to identity if not specified) 表示坐标轴在RPY方向上的旋转，单位为弧度。 连杆的质量属性 3×3旋转惯性矩阵，由六个独立的量组成：ixx, ixy, ixz, iyy, iyz, izz。 (可选) 连杆的可视化属性。用于指定连杆显示的形状（矩形、圆柱体等），同一连杆可以存在多个visual元素，连杆的形状为多个元素两个形成。一般情况下模型较为复杂可以通过soildwork绘制后生成stl调用，简单的形状如添加末端执行器等可以直接编写。同时可以在此处可根据理论模型和实际模型差距调整几何形状的位置。 (可选) 连杆几何形状的名字。 (可选，defaults to identity if not specified) 相对于连杆的坐标系的几何形状坐标系。 xyz (optional: defaults to zero vector) 表示x , y , z x,y,zx,y,z 方向的偏置，单位为米。 rpy (optional: defaults to identity if not specified) 表示坐标轴在RPY方向上的旋转，单位为弧度。 （必需） 可视化对象的形状，可以是下面的其中一种： 矩形，元素包含长、宽、高。原点在中心。 圆柱体，元素包含半径、长度。原点中心。 球体，元素包含半径。原点在中心。 网格，由文件决定，同时提供 scale ，用于界定其边界。推荐使用 Collada .dae 文件， 也支持.stl文件，但必须为一个本地文件。 (可选) 可视化组件的材料。可以在link标签外定义，但必需在robot标签内，在link标签外定义时，需引用link的名字。 (可选) 颜色，由 red/green/blue/alpha 组成，大小范围在 [0,1] 内。 (可选) 材料属性，由文件定义。 (可选) 连杆的碰撞属性。碰撞属性和连杆的可视化属性不同，简单的碰撞模型经常用来简化计算。同一个连杆可以有多个碰撞属性标签，连杆的碰撞属性表示由其定义的几何图形集构成。 (可选) 指定连杆几何形状的名称 (可选，defaults to identity if not specified) 碰撞组件的参考坐标系相对于连杆坐标系的参考坐标系。 xyz (可选， 默认零向量) 表示x , y , z x,y,zx,y,z 方向的偏置，单位为米。 rpy (可选， defaults to identity if not specified) 表示坐标轴在RPY方向上的旋转，单位为弧度。 与上述geometry元素描述相同 详细元素以及各个元素的作用可以前往官方文档进行查看 3.3 joint部分 joint部分描述了关节的运动学和动力学，并指定了关节的安全限值。 3.3.1 joint的属性： name： 指定关节的唯一名称 type： 指定关节的类型，其中类型可以是下列类型之一： revolute - 沿轴线旋转的铰链接头，其范围由上限和下限指定。 连续 - 一种连续铰链接头，围绕轴旋转，没有上限和下限。 棱柱形 - 沿轴滑动的滑动接头，其范围由上限和下限指定。 固定 - 这不是真正的关节，因为它不能移动。所有自由度都被锁定。这种类型的接头不需要轴，校准，动力学，极限或safety_controller。 浮动 - 此接头允许所有 6 个自由度的运动。 平面 - 此接头允许在垂直于轴的平面上运动。 3.3.2 joint的元素 (可选，defaults to identity if not specified) 从parent link到child link的变换，joint位于child link的原点，修改该参数可以调整连杆的位置，可用在调整实际模型与理论模型误差，但不建议大幅度修改，因为该参数影响连杆stl的位置，容易影响碰撞检测效果。 xyz (可选: 默认为零向量) 代表x , y , z x,y,zx,y,z轴方向上的偏移，单位米。 rpy (可选: 默认为零向量) 代表绕着固定轴旋转的角度：roll绕着x轴,pitch绕着y轴，yaw绕着z轴，用弧度表示。 (必需) parent link的名字是一个强制的属性。 link parent link的名字，是这个link在机器人结构树中的名字。 (必需) child link的名字是一个强制的属性。 link child link的名字，是这个link在机器人结构树中的名字。 (可选: 默认为(1,0,0)) joint的axis轴在joint的坐标系中。这是旋转轴(revolute joint)，prismatic joint移动的轴，是planar joint的标准平面。这个轴在joint坐标系中被指定。修改该参数可以调整关节的旋转所绕着的轴，常用于调整旋转方向，若模型旋向与实际相反，只需乘-1即可。固定(fixed)和浮动(floating)类型的joint不需要用到这个元素。 xyz(必需) 代表轴向量的x , y , z x,y,zx,y,z分量，为标准化的向量。 (可选) joint的参考点，用来矫正joint的绝对位置。 rising (可选) 当joint正向运动时，参考点会触发一个上升沿。 falling (可选) 当joint正向运动时，参考点会触发一个下降沿。 (可选) 该元素用来指定joint的物理性能。它的值被用来描述joint的建模性能，尤其是在仿真的时候。 (当关节为旋转或移动关节时为必需) 该元素为关节运动学约束。 lower (可选, 默认为0) 指定joint运动范围下界的属性(revolute joint的单位为弧度，prismatic joint的单位为米)，连续型的joint忽略该属性。 upper (可选, 默认为0) 指定joint运动范围上界的属性(revolute joint的单位为弧度，prismatic joint的单位为米)，连续型的joint忽略该属性。 effort (必需) 该属性指定了joint运行时的最大的力。 velocity (required) 该属性指定了joint运行时的最大的速度。 (可选) 这个标签用于指定已定义的 joint 来模仿已存在的 joint 。这个joint的值可以用以下公式计算： value = multiplier * other_joint_value + offset joint(必填) 需要模仿的joint的名字。 multiplier(可选) 指定上述公式中的乘数因子。 offset(可选) 指定上述公式中的偏移项。默认值为0 (可选) 该元素为安全控制限制，此元素下数据会读入到move_group中，但实际上时无效，move_group会跳过此处限制直接读取limit下的参数内容，同时设置该元素有几率会导致规划失败。 soft_lower_limit (可选, 默认为0) 该属性指定了joint安全控制边界的下界，是joint安全控制的起始限制点。这个值需要大于上述的limit中的lower值。 soft_upper_limit (可选, 默认为0) 该属性指定了joint安全控制边界的上界，是joint安全控制的起始限制点。这个值需要小于上述的limit中的upper值。 k_position(可选, 默认为0) 本属性用于说明位置和速度之间的关系。 k_velocity(必需) 本属性用于说明力和速度之间的关系。 详细元素以及各个元素的作用可以前往 http://wiki.ros.org/urdf/XML/joint 进行查看 4 常用命令工具 在ROS中，有许多常用的命令行工具，这些工具可以帮助你进行开发、调试、管理ROS节点等。以下是一些常用的ROS命令行工具： 4.1 编译工作空间 caktin_make 4.2 roscore 启动ROS主节点。在运行ROS节点之前，通常需要先启动roscore roscore 4.3 rosrun 运行指定的ROS节点。 rosrun package_name node_name 4.4 roslaunch 使用Launch文件启动一个或多个ROS节点。 roslaunch package_name launch_file.launch 4.5 rosnode 查看正在运行的ROS节点信息。 rosnode list rosnode info node_name 4.6 rostopic 查看正在运行的ROS话题信息。 rostopic list rostopic echo topic_name 4.7 rosservice 查看和调用ROS服务。 rosservice list rosservice call service_name 4.8 rosparam 获取和设置ROS参数。 rosparam get parameter_name rosparam set parameter_name value 4.9 rosmsg 查看ROS消息类型。 rosmsg show message_type 4.10 rosdep 安装ROS包的依赖项。 rosdep install package_name 4.11 环境变量 查看ROS_PACKAGE_PATH环境变量 echo $ROS_PACKAGE_PATH ← 上一页 | 下一页 → "},"11-ApplicationBaseROS/11.1-ROS1/11.1.3-RvizIntroduction.html":{"url":"11-ApplicationBaseROS/11.1-ROS1/11.1.3-RvizIntroduction.html","title":"3 Rviz 使用","keywords":"","body":"rviz的简单介绍及使用 rviz是ROS中一款三维可视化平台，一方面能够实现对外部信息的图形化显示，另外还可以通过 rviz 给对象发布控制信息，从而实现对机器人的监测与控制。 1 rviz界面简介 请先打开一个新的ROS1环境终端(快捷键Ctrl+Alt+T),输入如下指令： roscore 然后再打开一个ROS1环境终端(快捷键Ctrl+Alt+T)输入命令打开rviz rosrun rviz rviz # 或 rviz 打开rviz,显示如下界面： 1.1 各个区域介绍 左侧为显示器列表，显示器是在3D世界中绘制某些内容的东西，并且可能在显示列表中具有一些可用的选项。 上方是工具栏，允许用户用各种功能按键选择多种功能的工具 中间部分为3D视图: 它是可以用三维方式查看各种数据的主屏幕。3D视图的背景颜色、固定框架、网格等可以在左侧显示的全局选项（Global Options）和网格（Grid）项目中进行详细设置。 下方为时间显示区域，包括系统时间和ROS时间等。 右侧为观测视角设置区域，可以设置不同的观测视角。 本部分我们只进行粗略的介绍，如果您想了解更多详细的内容，可以前往用户指南进行查看。 2 简单使用 通过launch文件启动 本例子建立在您已经完成环境搭建，并成功将本公司的代码从GitHub上复制下来的基础上。 打开ROS1环境终端，然后运行命令：进行ROS的环境配置。 cd ~/catkin_ws/ source devel/setup.bash 再输入： roslaunch mercury_b1 test.launch 打开rviz，并得到如下结果： 如果您想了解更多rviz的相关资料信息，您可以前往官方文档进行查看 ← 上一页 | 下一页 → "},"11-ApplicationBaseROS/11.1-ROS1/11.1.4-BasicFunction.html":{"url":"11-ApplicationBaseROS/11.1-ROS1/11.1.4-BasicFunction.html","title":"4 基本功能案例","keywords":"","body":"机械臂的控制 1 滑块控制 打开一个ROS1环境终端，然后运行命令： roslaunch mercury_b1 slider_control.launch 它将打开 rviz 和一个滑块组件，你将看到如下画面： 接着你可以通过拖动滑块来控制 rviz 中的模型移动。如果你想让真实的 Mercury B1 跟着一起运动，需要再打开一个ROS1环境终端，然后运行命令： rosrun mercury_b1 slider_control.py 请注意：由于在命令输入的同时机械臂会移动到模型目前的位置，在您使用命令之前请确保rviz中的模型没有出现穿模现象 不要在连接机械臂后做出快速拖动滑块的行为，防止机械臂损坏 2 模型跟随 除了上面的控制，我们也可以让模型跟随真实的机械臂运动。打开一个ROS1环境终端，然后运行命令： rosrun mercury_b1 follow_display.py 然后打开另一个ROS1环境终端，然后运行命令： roslaunch mercury_b1 mercury_follow.launch 它将打开 rviz 展示模型跟随效果。 3 Moveit使用 mercury_b1 现已集成了 MoveIt 部分。 打开一个ROS1环境终端，然后运行命令： roslaunch mercury_b1_moveit mercury_b1.launch 如果需要让真实的机械臂同步执行计划，需要再打开一个ROS1环境终端，然后运行命令： rosrun mercury_b1_moveit sync_plan.py Moveit 的控制组有三个，运行效果如下： 1.左臂控制组： 通过拖动轨迹球来规划左臂的运动方向，再执行规划。 2.右臂控制组： 通过拖动轨迹球来规划右臂的运动方向，再执行规划。 3.腰部控制组： 可以通过设置目标姿态，再执行规划。 ← 上一页 | 下一节 → "},"11-ApplicationBaseROS/11.2-ROS2/":{"url":"11-ApplicationBaseROS/11.2-ROS2/","title":"5.3 机器人操作系统 2 (ROS2)","keywords":"","body":"ROS2 介绍 ROS2的前身是ROS，ROS就是机器人操作系统（Robot Operating System）。 但ROS本身并不是一个操作系统，而是一个软件库和工具集。 Ros的出现解决了机器人各个部件的通信问题。 后来，越来越多的机器人算法被集成到ROS中。 ROS2继承了ROS，比ROS更强大更好用。 1 ROS2的设计目标和特点 ROS2肩负着改变智能机器人时代的历史使命。 在设计之初，就考虑到满足各种机器人应用的需求。 多机器人系统： 未来机器人不再是独立的个体，机器人之间也需要交流和协作。 ROS2为多机器人系统的应用提供了标准的方法和通信机制。 跨平台： 机器人应用场景不同，使用的控制平台也会有很大差异。 为了让所有的机器人都能运行ROS2，ROS2可以跨平台运行在Linux、Windows、MacOS、RTOS上。 实时： 机器人运动控制和许多行为策略都要求机器人是实时的。 例如，机器人必须在 100 毫秒内可靠地检测到前方的行人，或在 1 毫秒内完成运动学和动力学计算。 ROS2 是像这样实时提供基本要求的。 产品化： 大量的机器人已经进入我们的生活，未来还会越来越多，ROS2不仅可以用于机器人研发阶段，还可以直接安装在 产品并进入消费市场。 这也对ROS2的稳定性和鲁棒性提出了巨大的挑战。 项目管理： 机器人开发是一项复杂的系统工程。 设计、开发、调试、测试、部署全过程的项目管理工具和机制也将在ROS2中得到体现，方便我们开发机器人。 2 发行版本 ROS2和Ubuntu对应的发行版本和维护周期。 ROS2 版本 发布日期 维护期限 Ubuntu 版本 Dashing 2019.5 2021.5 Ubuntu 18.04 (Bionic Beaver) Eloquent 2019.11 2020.11 Ubuntu 18.04 (Bionic Beaver) Foxy 2020.6 2023.5 Ubuntu 20.04(Focal Fossa) Galactic 2021.5 2022.11 Ubuntu 20.04(Focal Fossa) Humble 2022.5 2027.5 Ubuntu 22.04(Jammy Jellyfish) 3 ROS和ROS2的比较 ROS2重新设计了系统架构。 两代ROS的架构变化如下： OS Layer： OS层。在ROS2中，它可以构建在linux或其他系统上，甚至是没有操作系统的裸机。 Middleware Layer： 中间件层。ROS1的通信系统基于TCPROS/UDPROS，而ROS2的通信系统基于DDS。 DDS是分布式实时系统中数据发布/订阅的标准解决方案。 Application Layer： 应用层。ROS1依赖于ROS Master，而在ROS2中，节点之间使用了一种名为“Discovery”的发现机制来帮助彼此建立连接。 ROS设计了一套完整的通信机制（主题、服务、参数、动作）来简化机器人开发。 通过这种机制，可以连接机器人的各个部件。 这种机制设计了一个叫做Ros Master的节点，所有其他组件的通信都必须经过master节点。 一旦主节点挂掉，就会导致整个机器人系统的通信崩溃！ 所以不能利用Ros的不稳定性来做一些自动驾驶等高风险的机器人。 此外，还有以下缺点： 基于TCP的通信实时性差，系统开销大 对 python3 支持不友好 消息机制不兼容 无加密机制，安全性低 ROS2首先移除ROS中存在的master节点。 去掉主节点后，各个节点可以通过DDS节点相互发现，各个节点是平等的，可以实现一对一、一对多、多对多的通信。 使用DDS进行通信后，可靠性和稳定性得到了增强。 与只支持Linux系统的ROS相比，ROS2还支持windows、mac甚至RTOS平台。 ← 上一节 | 下一页 → "},"11-ApplicationBaseROS/11.2-ROS2/11.2.1-EnvironmentBuilding.html":{"url":"11-ApplicationBaseROS/11.2-ROS2/11.2.1-EnvironmentBuilding.html","title":"1 环境搭建","keywords":"","body":"Linux系统环境: 系统出厂自带Ubuntu（V-20.04）系统，内置 ROS2 Galactic 开发环境，无需搭建和管理，只需更新mercury_ros2包即可。 mercury_ros2是大象机器人推出的适用于其Mercury B1系列机械臂的ROS2包 ROS2项目地址: http://github.com/elephantrobotics/mercury_ros2 机械臂API驱动库地址: https://github.com/elephantrobotics/pymycobot 1 更新 mercury_ros2 包 为了保证用户能及时使用最新的官方包，可以通过文件管理器进入/home/er文件夹，打开ROS2环境终端，然后运行命令更新： # 克隆github上的代码 cd colcon_ws/src # 进入工作区的src文件夹中 git clone --depth 1 https://github.com/elephantrobotics/mercury_ros2.git cd .. # 返回工作区 colcon build --symlink-install # 构建工作区中的代码，--symlink-install：避免每次调整 python 脚本时都需要重新编译 source install/setup.bash # 添加环境变量 注意: 如果在/home/er/colcon_ws/src（相当于~/colcon_ws/src）目录下已经存在mercury_ros2文件夹，则需要先删除原来的mercury_ros2，然后再执行上述命令。 其中，目录路径中的er为系统的用户名。 至此ROS2环境搭建完成，你可以学习ROS2的基础知识 或者ROS2使用案例。 ← 上一页 | 下一页 → "},"11-ApplicationBaseROS/11.2-ROS2/11.2.2-ROS2_Basics.html":{"url":"11-ApplicationBaseROS/11.2-ROS2/11.2.2-ROS2_Basics.html","title":"2 ROS2 基础","keywords":"","body":"1 ROS2工程结构 1.1 colcon工作空间 colocn工作空间是创建、修改、编译软件包的目录。colcon的工作空间，直观的形容就是一个仓库，里面装载着ROS的各种项目工程，便于系统组织管理调用。 创建工作空间： mkdir -p ~/colcon_ws/src # 创建文件夹 cd ~/colcon_ws/ # 进入文件夹 colcon build # 构建工作区中的代码。 注意： colcon 支持选项 --symlink-install 。这允许通过更改 source 空间中的文件（例如 Python 文件或其他未编译的资源）来更改已安装的文件，以加快迭代速度。避免每次修改 python 脚本时都需要重新编译。 colcon build --symlink-install ROS2工作空间是一个具有特定结构的目录。通常有一个 src 子目录。在该子目录中是 ROS2 包的源代码所在的位置。通常，目录以其他方式为空开始。 colcon 会进行源代码构建。默认情况下，它将创建以下目录作为 src 目录的同级目录： src/: ROS2的colcon软件包（源代码包） build/: 存储中间文件的位置。对于每个包，将创建一个子文件夹，例如在其中调用 CMake。 install/: 每个包的安装位置。默认情况下，每个包都将安装到单独的子目录中。 log/: 包含有关每个 colcon 调用的各种日志记录信息。 一个ROS2工作空间目录结构如下所示： WorkSpace --- 自定义的工作空间。 |--- build：存储中间文件的目录，该目录下会为每一个功能包创建一个单独子目录。 |--- install：安装目录，该目录下会为每一个功能包创建一个单独子目录。 |--- log：日志目录，用于存储日志文件。 |--- src：用于存储功能包源码的目录。 |-- C++功能包 |-- package.xml：包信息，比如:包名、版本、作者、依赖项。 |-- CMakeLists.txt：配置编译规则，比如源文件、依赖项、目标文件。 |-- src：C++源文件目录。 |-- include：头文件目录。 |-- msg：消息接口文件目录。 |-- srv：服务接口文件目录。 |-- action：动作接口文件目录。 |-- Python功能包 |-- package.xml：包信息，比如:包名、版本、作者、依赖项。 |-- setup.py：与C++功能包的CMakeLists.txt类似。 |-- setup.cfg：功能包基本配置文件。 |-- resource：资源目录。 |-- test：存储测试相关文件。 |-- 功能包同名目录：Python源文件目录。 1.2 ROS2软件包 Package不仅是Linux上的软件包，也是colcon编译得基本单元，我们使用 colcon build 编译的对象就是每个ROS2的package。 创建自己的软件包: 使用Python创建软件包的命令语法为： ros2 pkg create --build-type ament_python 例如： ros2 pkg create --build-type ament_python --node-name my_node my_package 2 基本工具命令 在本章中，您将了解ROS2的常用命令工具。 2.1 Topics ROS 2 将复杂的系统分解为许多模块化节点。 Topics是 ROS 图的重要元素，充当节点交换消息的总线。 Topics是数据在节点之间移动的主要方式之一，因此在系统的不同部分之间移动。 具体参考: 官方教程 topics 帮助 ros2 topics -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 节点关系图 rqt_graph 了解topics相关命令 ros2 topics -h 话题列表 ros2 topic list ros2 topic list -t # 显示相应的消息类型 查看话题内容 ros2 topic echo ros2 topic echo /turtle1/cmd_vel 显示话题相关信息，类型 ros2 topic info # 输出 /turtle1/cmd_vel 话题接口相关信息 ros2 topic info /turtle1/cmd_vel 显示接口相关信息 ros2 interface show # 输出 geometry_msgs/msg/Twist接口相关信息 ros2 interface show geometry_msgs/msg/Twist 发布命令 ros2 topic pub '' # 发布速度命令 ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" # 按一定频率发布速度命令 ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 查看话题发布的频率 ros2 topic hz #输出/turtle1/cmd_vel发布频率 ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" 2.2 Nodes ROS 中的每个节点都应该负责一个单一的模块用途（例如，一个节点用于控制车轮电机，一个节点用于控制激光测距仪等）。 每个节点都可以通过主题、服务、操作或参数向其他节点发送和接收数据。 一个完整的机器人系统由许多协同工作的节点组成。 在 ROS 2 中，单个可执行文件（C++ 程序、Python 程序等）可以包含一个或多个节点。 具体参考: 官方教程 nodes 帮助 ros2 nodes -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 查看节点列表 ros2 node list 查看节点关系图 rqt_graph 重映射 ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle ros2 node list 查看节点信息 ros2 node info ros2 node info /my_turtle 2.3 Services 服务是 ROS 图中节点的另一种通信方法。 服务基于调用和响应模型，而不是主题的发布者-订阅者模型。 虽然主题允许节点订阅数据流并获得持续更新，但服务仅在客户端专门调用时才提供数据。 具体参考: 官方教程 services 帮助 ros2 service -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 查看服务列表 ros2 service list # 显示服务列表及消息类型 ros2 service list -t 查看服务接收到的消息类型 ros2 service type ros2 service type /clear 找到使用某类消息类型的服务 ros2 service find ros2 service find std_srvs/srv/Empty 查看服务消息类型定义 ros2 interface show .srv ros2 interface show std_srvs/srv/Empty.srv 调用服务命令,清除行走轨迹 ros2 service call ros2 service call /clear std_srvs/srv/Empty 生成新乌龟 ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: 'turtle2'}\" 2.4 Parameters 参数是节点的配置值。 您可以将参数视为节点设置。 节点可以将参数存储为整数、浮点数、布尔值、字符串和列表。 在 ROS 2 中，每个节点都维护自己的参数。 有关参数的更多背景信息，请参阅概念文档。 具体参考: 官方教程 parameters 帮助 ros2 param -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 查看服务列表 ros2 param list 获取参数值 ros2 param get ros2 param get /turtlesim background_g 设置参数值 ros2 param set ros2 param set /turtlesim background_r 150 导出参数值 ros2 param dump ros2 param dump /turtlesim 独立导入参数 ros2 param load ros2 param load /turtlesim ./turtlesim.yaml 启动节点同时导入参数 ros2 run --ros-args --params-file ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml 2.5 Actions 动作是 ROS 2 中的一种通信类型，用于长时间运行的任务。 它们由三部分组成：目标、反馈和结果。 操作基于主题和服务。 它们的功能类似于服务，除了操作是可抢占的（您可以在执行时取消它们）。 他们还提供稳定的反馈，而不是返回单一响应的服务。 操作使用客户端-服务器模型，类似于发布者-订阅者模型（在主题教程中描述）。 “动作客户端”节点将目标发送到“动作服务器”节点，该节点确认目标并返回反馈流和结果。 具体参考: 官方教程 action 帮助 ros2 action -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 按G|B|V|C|D|E|R|T 实现旋转，按F键盘取消l 查看节点action的服务端和客户端 ros2 node info /turtlesim 查看动作列表 ros2 action list ros2 action list -t # 显示动作类型 查看动作信息 ros2 action info ros2 action info /turtle1/rotate_absolute 查看动作消息内容 ros2 interface show turtlesim/action/RotateAbsolute 发送动作目标信息 ros2 action send_goal ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 1.57}\" # 带反馈信息 ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 0}\" --feedback 2.6 RQt RQt 是一个图形用户界面框架，它以插件的形式实现各种工具和界面。 可以将所有现有的 GUI 工具作为 RQt 中的可停靠窗口运行！ 这些工具仍然可以以传统的独立方式运行，但 RQt 可以更轻松地在单个屏幕布局中管理所有不同的窗口。 具体参考: 官方教程 您可以通过以下方式轻松运行任何 RQt 工具/插件： rqt rqt 帮助 rqt -h 启动turtlesim和键盘控制 ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key 动作浏览器: / Plugins -> Actions ->Action Type Browser 参数重配置: / Plugins -> configuration ->Parameter Reconfigure 节点图: /Node Graph 控制转向: /Plugins -> Robot Tools -> Robot Steering 服务调用: /Plugins -> Services -> Service Caller 服务类型浏览器: Plugins -> Services -> Service Type Browser 消息发布: Plugins -> Topics -> Message Publisher 消息类型浏览器: Plugins -> Topics -> Message Type Browser 话题列表: Plugins -> Topics -> Topic Monitor 绘制曲线图: Plugins -> Visualization -> Plot 查看日志: rqt_console ros2 run rqt_console rqt_console ros2 run turtlesim turtlesim_node ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}\" 2.7 TF2 tf2 是变换库，它允许用户随着时间的推移跟踪多个坐标系。 tf2 以时间缓冲的树结构维护坐标系之间的关系，并让用户在任何需要的时间点在任意两个坐标系之间变换点、向量等。 具体参考: 官方教程 让我们从安装演示包及其依赖项开始。 sudo apt-get install ros-foxy-turtle-tf2-py ros-foxy-tf2-tools ros-foxy-tf-transformations 跟随 launch启动2个小乌龟，第一个小乌龟自动跟随第二个 ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py 通过键盘控制第一个小乌龟移动 ros2 run turtlesim turtle_teleop_key 查看TF树 ros2 run tf2_tools view_frames.py evince frames.pdf 查看两个坐标系之间的关系 ros2 run tf2_ros tf2_echo [reference_frame] [target_frame] ros2 run tf2_ros tf2_echo turtle2 turtle1 在rviz上查看TF关系 ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz 2.8 URDF URDF 是统一机器人描述格式，用于指定 ROS 中的机器人几何和组织。 具体参考: 官方教程 完整语法 # describe: # Parameters: name=\"\" # Child node: # Description: # Parameters：name=\"\" # Child node: # describe: # Parameters: # child nodes: # description # parameters # Child node: # Description: # Parameters: # length=\"0.6\" # radius=\"0.2\" # description # Parameters:size=\"0.6 0.1 0.2\" # Description #Parameters: filename=\"package://urdf_tutorial/meshes/l_finger_tip.dae\" # Description: collision element, prioritized # parameters # child node # description # parameters # Child nodes: # description: mass # Parameters: value=10 # Description: Inertia # Parameters: i+\"Cartesian product of xyz\" (9 in total)=\"0.4\" # Description: # Parameters: # rpy=\"0 1.5 0\" # xyz=\"0 0 -0.3\" # Description # Parameters：name=\"blue\" # Description # Parameters： # name=\"\" # type=\"\" # fixed # prismatic # child node # Description # Parameters：link=\"\" # Description： # Parameters：link=\"\" # Description： # Parameters：xyz=\"0 -0.2 0.25\" # Description # Parameters： # effort=\"1000.0\" maximum effort # lower=\"-0.38\" Joint upper limit (radians) # upper=\"0\" Joint lower limit (radians) # velocity=\"0.5\" Maximum velocity # Description： Press ? axis rotation # Parameters：xyz=\"0 0 1\"，along the Z axis # Description： # Parameters：name=\"blue\" # child node： # description： # Parameters：rgba=\"0 0 0.8 1\" 安装依赖库 sudo apt install ros-foxy-joint-state-publisher-gui ros-foxy-joint-state-publisher sudo apt install ros-foxy-xacro 下载源代码 cd ~/dev_ws git clone -b ros2 https://github.com/ros/urdf_tutorial.git src/urdf_tutorial 编译源代码 colcon build --packages-select urdf_tutorial 运行示例 ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf 2.9 Launch ROS 2 中的启动系统负责帮助用户描述他们系统的配置，然后按照描述执行。 系统的配置包括要运行的程序、运行它们的位置、传递给它们的参数，以及 ROS 特定的约定，这些约定通过为每个组件提供不同的配置，使得在整个系统中重用组件变得容易。 它还负责监视已启动流程的状态，并报告和/或响应这些流程状态的变化。 用 Python、XML 或 YAML 编写的launch文件可以启动和停止不同的节点，以及触发和处理各种事件。 具体参考: 官方教程 Setup 创建一个新目录来存储您的launch文件： mkdir launch 编写启动文件 让我们使用 turtlesim 包及其可执行文件将 ROS 2 启动文件放在一起。 正如刚才提到的。 将完整代码复制并粘贴到 launch/turtlesim_mimic_launch.py 文件中： from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description(): return LaunchDescription([ Node( package='turtlesim', namespace='turtlesim1', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', namespace='turtlesim2', executable='turtlesim_node', name='sim' ), Node( package='turtlesim', executable='mimic', name='mimic', remappings=[ ('/input/pose', '/turtlesim1/turtle1/pose'), ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'), ] ) ]) 运行ros2启动文件 要运行上面创建的launch文件，请进入您之前创建的目录并运行以下命令： 语法格式为： ros2 launch cd launch ros2 launch turtlesim_mimic_launch.py launch 帮助 ros2 launch -h 运行节点 ros2 launch turtlesim multisim.launch.py 查看launch文件有哪些参数 ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py -s ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py --show-arguments ros2 launch turtlebot3_bringup robot.launch.launch.py -s 运行launch文件带参数 ros2 launch turtlebot3_bringup robot.launch.launch.py usb_port:=/dev/opencr 运行节点并调试 ros2 launch turtlesim turtlesim_node.launch.py -d 只输出节点描述 ros2 launch turtlesim turtlesim_node.launch.py -p 运行组件 ros2 launch composition composition_demo.launch.py 2.10 Run run用于运行单个节点，组件程序。 run 帮助 ros2 run -h 运行节点 ros2 run turtlesim turtlesim_node 运行节点带参数 ros2 run turtlesim turtlesim_node --ros-args -r __node:=turtle2 -r __ns:=/ns2 运行组件容器 ros2 run rclcpp_components component_container 运行组件 ros2 run composition manual_composition 2.11 Package 一个包可以被认为是你的 ROS 2 代码的容器。 如果您希望能够安装您的代码或与他人共享，那么您需要将其组织在一个包中。 借助软件包，您可以发布您的 ROS 2 作品并允许其他人轻松构建和使用它。 ROS 2 中的包创建使用 ament 作为其构建系统，并使用 colcon 作为其构建工具。 您可以使用官方支持的 CMake 或 Python 创建包，但确实存在其他构建类型。 具体参数: 官方教程 创建工作空间 为每个新工作区创建一个新目录。 名称并不重要，但它有助于表明工作区的用途。 让我们为“开发工作区”选择目录名称 ros2_ws： mkdir -p ~/ros2_ws/src cd ~/ros2_ws/src pkg 帮助 ros2 pkg -h 列出功能包 ros2 pkg executable turtlesim 输出某个功能包可执行程序 ros2 pkg executable turtlesim 创建Python功能包 在运行包创建命令之前，请确保您位于 src 文件夹中。 cd ~/ros2_ws/src 在 ROS 2 中创建新包的命令语法是： ros2 pkg create --build-type ament_python # 您将使用可选参数 --node-name 在包中创建一个简单的 Hello World 类型可执行文件。 ros2 pkg create --build-type ament_python --node-name my_node my_package 构建package 将包放在工作区中特别有价值，因为您可以通过在工作区根目录中运行 colcon build 来一次构建许多包。 否则，您将不得不单独构建每个包。 # 返回到工作区目录： cd ~/ros2_ws # 现在你可以构建你的包： colcon build Source setup文件 要使用您的新包和可执行文件，首先打开一个新终端并获取您的主要 ROS 2 安装源。 然后，从 ros2_ws 目录中，运行以下命令来获取您的工作空间： source install/setup.bash 现在您的工作区已添加到您的路径中，您将能够使用新包的可执行文件。 使用 package 要运行您在包创建期间使用 --node-name 参数创建的可执行文件，请输入以下命令： ros2 run my_package my_node ← 上一页 | 下一页 → "},"11-ApplicationBaseROS/11.2-ROS2/11.2.3-Rviz2Introduction.html":{"url":"11-ApplicationBaseROS/11.2-ROS2/11.2.3-Rviz2Introduction.html","title":"3 Rviz2 使用","keywords":"","body":"rviz2的简单介绍及使用 Rviz2是一个可视化工具，用于显示机器人环境中的消息，提供3D视角来查看机器人的状态和活动。它可以帮助开发者更好地理解机器人当前的状态和活动，以及其他可视化消息。Rviz2提供了一系列的可视化工具，可以帮助开发者更好地理解机器人的状态和活动，比如可视化坐标系、激光扫描消息、点云消息、机器人模型等等。使用Rviz2，可以轻松地查看和调试机器人系统，从而更好地实现机器人目标。 1 rviz2的安装及界面简介 ros2安装成功表明rviz2也一起安装成功了，因为ros2的安装包含了rviz2。 点击桌面上的ROS2 Shell图标或者桌面下方栏的对应图标，打开ROS2环境终端，输入命令打开rviz2： ros2 run rviz2 rviz2 # 或 rviz2 打开rviz2,显示如下界面： 1.1 各个区域介绍 左侧为显示器列表，显示器是在3D世界中绘制某些内容的东西，并且可能在显示列表中具有一些可用的选项。包括添加、删除、复制、重命名插件，显示插件，以及设置插件属性等功能。 上方是工具栏，允许用户用各种功能按键选择多种功能的工具 中间部分为3D视图: 它是可以用三维方式查看各种数据的主屏幕。3D视图的背景颜色、固定框架、网格等可以在左侧显示的全局选项（Global Options）和网格（Grid）项目中进行详细设置。 下方为时间显示区域，包括系统时间和ROS时间等。 右侧为观测视角设置区域，可以设置不同的观测视角。 本部分我们只进行粗略的介绍，如果您想了解更多详细的内容，可以前往用户指南进行查看。 2 简单使用 通过launch文件启动 本例子建立在您已经完成环境搭建，并成功将本公司的代码从GitHub上复制下来的基础上。 打开ROS2环境终端，输入以下命令进行ROS2的环境配置。 cd ~/colcon_ws/ colcon build --symlink-install source install/setup.bash 再输入： ros2 launch mercury_b1 test.launch.py 打开rviz，并得到如下结果： 如果您想了解更多rviz的相关资料信息，您可以前往官方文档进行查看 ← 上一页 | 下一页 → "},"11-ApplicationBaseROS/11.2-ROS2/11.2.4-BasicFunction.html":{"url":"11-ApplicationBaseROS/11.2-ROS2/11.2.4-BasicFunction.html","title":"4 基本功能案例","keywords":"","body":"机械臂的控制 1 滑块控制 打开一个ROS2环境终端，然后运行命令： ros2 launch mercury_b1 slider_control.launch.py 它将打开 rviz 和一个滑块组件，你将看到如下画面： 接着你可以通过拖动滑块来控制 rviz2 中的模型移动。真实的 Mercury B1 将跟着一起运动。 请注意：由于在命令输入的同时机械臂会移动到模型目前的位置，在您使用命令之前请确保rviz2中的模型没有出现穿模现象 不要在连接机械臂后做出快速拖动滑块的行为，防止机械臂损坏 2 模型跟随 除了上面的控制，我们也可以让模型跟随真实的机械臂运动。打开一个ROS2环境终端，然后运行命令： ros2 launch mercury_b1 mercury_follow.launch.py 它将打开 rviz 展示模型跟随效果。 ← 上一页 | 下一节 → "},"7-ExamplesRobotsUsing/7-ExamplesRobotsUsing.html":{"url":"7-ExamplesRobotsUsing/7-ExamplesRobotsUsing.html","title":"6 机器人使用案例","keywords":"","body":"7 机械臂使用场景案例 本章节呈现了经典的机械臂使用案例，以展示产品在富有代表性的场景中的应用。这包括了机械臂在不同领域的典型应用，突显了产品的多功能性和适用性。通过这些案例，用户可以深入了解机械臂在实际应用中的灵活性和效能，为他们在特定场景中的应用提供参考。 移动抓取木块案例 from uvc_camera import UVCCamera from arm_control import * from marker_utils import * import stag # 夹爪工具长度 Tool_LEN = 175 # 相机中心到法兰距离 Camera_LEN = 78 np.set_printoptions(suppress=True, formatter={'float_kind': '{:.2f}'.format}) # 相机配置文件 camera_params = np.load(\"src/camera_params.npz\") mtx, dist = camera_params[\"mtx\"], camera_params[\"dist\"] # 二维码大小 MARKER_SIZE = 32 # 设置左臂端口 ml = Mercury(\"/dev/ttyTHS0\") # 将旋转矩阵转为欧拉角 def CvtRotationMatrixToEulerAngle(pdtRotationMatrix): pdtEulerAngle = np.zeros(3) pdtEulerAngle[2] = np.arctan2(pdtRotationMatrix[1, 0], pdtRotationMatrix[0, 0]) fCosRoll = np.cos(pdtEulerAngle[2]) fSinRoll = np.sin(pdtEulerAngle[2]) pdtEulerAngle[1] = np.arctan2(-pdtRotationMatrix[2, 0], (fCosRoll * pdtRotationMatrix[0, 0]) + (fSinRoll * pdtRotationMatrix[1, 0])) pdtEulerAngle[0] = np.arctan2((fSinRoll * pdtRotationMatrix[0, 2]) - (fCosRoll * pdtRotationMatrix[1, 2]), (-fSinRoll * pdtRotationMatrix[0, 1]) + (fCosRoll * pdtRotationMatrix[1, 1])) return pdtEulerAngle # 将欧拉角转为旋转矩阵 def CvtEulerAngleToRotationMatrix(ptrEulerAngle): ptrSinAngle = np.sin(ptrEulerAngle) ptrCosAngle = np.cos(ptrEulerAngle) ptrRotationMatrix = np.zeros((3, 3)) ptrRotationMatrix[0, 0] = ptrCosAngle[2] * ptrCosAngle[1] ptrRotationMatrix[0, 1] = ptrCosAngle[2] * ptrSinAngle[1] * ptrSinAngle[0] - ptrSinAngle[2] * ptrCosAngle[0] ptrRotationMatrix[0, 2] = ptrCosAngle[2] * ptrSinAngle[1] * ptrCosAngle[0] + ptrSinAngle[2] * ptrSinAngle[0] ptrRotationMatrix[1, 0] = ptrSinAngle[2] * ptrCosAngle[1] ptrRotationMatrix[1, 1] = ptrSinAngle[2] * ptrSinAngle[1] * ptrSinAngle[0] + ptrCosAngle[2] * ptrCosAngle[0] ptrRotationMatrix[1, 2] = ptrSinAngle[2] * ptrSinAngle[1] * ptrCosAngle[0] - ptrCosAngle[2] * ptrSinAngle[0] ptrRotationMatrix[2, 0] = -ptrSinAngle[1] ptrRotationMatrix[2, 1] = ptrCosAngle[1] * ptrSinAngle[0] ptrRotationMatrix[2, 2] = ptrCosAngle[1] * ptrCosAngle[0] return ptrRotationMatrix # 坐标转换为齐次变换矩阵，（x,y,z,rx,ry,rz）单位rad def Transformation_matrix(coord): position_robot = coord[:3] pose_robot = coord[3:] # 将欧拉角转为旋转矩阵 RBT = CvtEulerAngleToRotationMatrix(pose_robot) PBT = np.array([[position_robot[0]], [position_robot[1]], [position_robot[2]]]) temp = np.concatenate((RBT, PBT), axis=1) array_1x4 = np.array([[0, 0, 0, 1]]) # 将两个数组按行拼接起来 matrix = np.concatenate((temp, array_1x4), axis=0) return matrix def Eyes_in_hand_left(coord, camera): # 相机坐标 Position_Camera = np.transpose(camera[:3]) # 机械臂坐标矩阵 Matrix_BT = Transformation_matrix(coord) # 手眼矩阵 Matrix_TC = np.array([[0, -1, 0, Camera_LEN], [1, 0, 0, 0], [0, 0, 1, -Tool_LEN], [0, 0, 0, 1]]) # 物体坐标（相机系） Position_Camera = np.append(Position_Camera, 1) # 物体坐标（基坐标系） Position_B = Matrix_BT @ Matrix_TC @ Position_Camera return Position_B # 等待机械臂运行结束 def waitl(): time.sleep(0.2) while (ml.is_moving()): time.sleep(0.03) # 获取物体坐标(相机系) def calc_markers_base_position(corners: NDArray, ids: T.List, marker_size: int, mtx: NDArray, dist: NDArray) -> T.List: if len(corners) == 0: return [] # 通过二维码角点获取物体旋转向量和平移向量 rvecs, tvecs = solve_marker_pnp(corners, marker_size, mtx, dist) for i, tvec, rvec in zip(ids, tvecs, rvecs): tvec = tvec.squeeze().tolist() rvec = rvec.squeeze().tolist() rotvector = np.array([[rvec[0], rvec[1], rvec[2]]]) # 将旋转向量转为旋转矩阵 Rotation = cv2.Rodrigues(rotvector)[0] # 将旋转矩阵转为欧拉角 Euler = CvtRotationMatrixToEulerAngle(Rotation) # 物体坐标(相机系) target_coords = np.array([tvec[0], tvec[1], tvec[2], Euler[0], Euler[1], Euler[2]]) return target_coords if __name__ == \"__main__\": # 设置摄像头id camera = UVCCamera(5, mtx, dist) # 打开摄像头 camera.capture() # 设置左臂观察点 origin_anglesL = [-44.24, 15.56, 0.0, -102.59, 65.28, 52.06, 23.49] # 设置夹爪运动模式 ml.set_gripper_mode(0) # 设置工具坐标系 ml.set_tool_reference([0, 0, Tool_LEN, 0, 0, 0]) # 将末端坐标系设置为工具 ml.set_end_type(1) # 设置移动速度 sp = 40 # 移动到观测点 ml.send_angles(origin_anglesL, sp) # 等待机械臂运动结束 waitl() # 刷新相机界面 camera.update_frame() # 获取当前帧 frame = camera.color_frame() # 获取画面中二维码的角度和id (corners, ids, rejected_corners) = stag.detectMarkers(frame, 11) # 获取物的坐标(相机系) marker_pos_pack = calc_markers_base_position(corners, ids, MARKER_SIZE, mtx, dist) # 获取机械臂当前坐标 cur_coords = np.array(ml.get_base_coords()) # 将角度值转为弧度值 cur_bcl = cur_coords.copy() cur_bcl[-3:] *= (np.pi / 180) # 通过矩阵变化将物体坐标(相机系)转成(基坐标系) fact_bcl = Eyes_in_hand_left(cur_bcl, marker_pos_pack) target_coords = cur_coords.copy() target_coords[0] = fact_bcl[0] target_coords[1] = fact_bcl[1] target_coords[2] = fact_bcl[2] + 50 # 机械臂移动到二维码上方 ml.send_base_coords(target_coords, 30) # 等待机械臂运动结束 waitl() # 打开夹爪 ml.set_gripper_value(100, 100) # 机械臂沿z轴向下移动 ml.send_base_coord(3, fact_bcl[2], 10) # 等待机械臂运动结束 waitl() # 闭合夹爪 ml.set_gripper_value(20, 100) # 等待夹爪闭合 time.sleep(2) # 抬起夹爪 ml.send_base_coord(3, fact_bcl[2] + 50, 10) "},"9-AboutUs/":{"url":"9-AboutUs/","title":"7 关于我们","keywords":"","body":""},"9-AboutUs/9.1-company.html":{"url":"9-AboutUs/9.1-company.html","title":"7.1 大象机器人","keywords":"","body":"大象机器人 1 公司简介 大象机器人(Elephant Robotics)立足于中国·深圳，是一家专注于机器人研发设计及自动化解决方案的高新科技企业。 我们致力于为机器人教育及科研机构、商业场景、工业生产提供高柔性的协作机器人、简单易学的操作系统以及智能的自动化解决方案。其产品质量及智慧方案备受韩国、日本、美国、德国、意大利、希腊等数家来自世界500强名企工厂的一致认可与好评。 大象机器人秉持“Enjoy Robots World”的愿景，倡导人与机器人的协同工作，让机器人成为人类工作生活的好帮手，帮助人们从简单、重复、枯燥的工作中解放出来，充分发挥人机协同优势，进而提高工作效率，帮助人类缔造美好新生活。 未来，大象机器人希望通过新一代尖端科技推动机器人产业发展，携手与客户伙伴们共同开启自动化智能化新时代。 2 发展历程 2016.08 -----大象机器人有限公司正式成立 2016.08 -----进入 HAX 孵化器，获得 SOSV 种子轮投资 2016.08 ----- 开始研发 Elephant S 工业协作机器人 2017.01 -----获评 “CES 中国最具创新企业 Top10” 2017.04 -----出席汉诺威工业博览会及韩国自动化展览会 2017.07 -----两位创始人入选福布斯亚洲评选的“30 位 30 岁以下商业精英” 2017.10 -----第五代单臂工业协作机器人 Elephant S 问世 2018.04 -----获得”云天使基金”天使轮投资 2018.06 -----首次公开亮相 2018 年汉诺威世界工业博览会 2018.06 -----获得长江商学院“智造创业 MBA 奖” 2018.06 -----获得清华经管“创业加速器 X-elerator 奖” 2018.11 -----获得亚洲智能硬件大赛深圳赛区第二名 2018.11 -----获得高工金球奖“最具投资企业奖” 2019.03 -----获得高工金球奖“领军人物奖” 2019.04 -----2019年3月 Catbot获“工业机器人创新奖” 2019.09 -----出席华为欧洲生态大会(HCE)，正式成为华为生态伙伴一员 2019.11 -----大象机器人携手哈工大出席IROS国际智能机器人与系统大会 2019.12 -----大象机器人-华南理工大学“智能机器人联合开发实验室”正式揭牌 2019.12 -----荣获高工2019年度“创新技术奖” 2019.12 -----荣获高工2019年度“十大快速成长企业” 2019.12 -----荣获深圳装备工业-工业机器人细分领域-“新锐企业奖” 2019.12 -----世界首款仿生机器猫MarsCat问世 2020.05 -----创始人获得2019年度深圳市机器人新锐人物奖 2020.10 -----全球最轻最小的六轴协作机器人myCobot问世 2021.03 -----面向科研的最小协作机器人myCobotPro 320问世 2021.05 -----火星仿生猫MarsCat获得新华财经、中国日报、南京日报、哈尔滨日报等多家媒体的竞相报道 2021.07 -----发布最小的复合机器人底盘 – 小象移动机器人myAGV 2021.09 -----全球首款全包裹式的四轴机械臂-小象码垛机械臂myPalletizer问世 2022.01 -----获36氯、极客公园关于大象机器人在轻是化消费级机器人行业系列报道 2022.02 -----MarsCat、myCobot 亮相春晚夫视频直播，参与深圳卫视过年特备节目 2022.05 -----最紧凑的小六轴机械臂mechArm 问世，能人工智能机器人教育 2022.06 -----联合Unity引擎，基于myCobot 机器人，推出人工智能机器人实践入门书+籍(国际课程) 2022.07 -----发布人工智能时代的仿真陪伴机器猫米塔猫metaCat 2022.07 -----发布史上最小双臂协作机器人mybuddy 2022.08 -----获得“十大非工业技术创新奖” 2022.08 -----创始人获“2022深圳市机器人新锐人物奖” 2022.11 -----科大讯飞AI开发者大赛real time enganement（实时互动）赛道亚军 2022.11 -----2022世界声博会1024科博展最佳机器人奖 2022.12 -----央视报道 3 相关链接 官网：https://www.elephantrobotics.com 购买链接 淘宝：https://shop504055678.taobao.com shopify：https://shop.elephantrobotics.com/ 视频 bilibili：大象机器人的个人空间-大象机器人个人主页-哔哩哔哩视频 youtube：Elephant Robotics - YouTube Facebook : https://www.facebook.com/mycobotcreator/ Linkedin : https://www.linkedin.com/company/18319865 X (Twitter) : https://twitter.com/CobotMy Discord : https://discord.gg/2MAherp7nt Hackster : https://www.hackster.io/elephant-robotics ← Previous Page| Next Page → "},"9-AboutUs/9.2-contact.html":{"url":"9-AboutUs/9.2-contact.html","title":"7.2 联系我们","keywords":"","body":"联系我们 我们的工作时间是在中国工作日，从上午10点到下午6点。 如果您还有其他问题，请通过以下方式与我们联系。 电子邮件 ： 如果您有购买意图或任何参数问题，请将电子邮件发送到此邮箱。 电子邮件： sales@elephantrobotics.com 如果列出的问题无法帮助您解决，并且您有更多的售后问题，请发送电子邮件到此邮箱。 电子邮件： support@elephantrobotics.com 我们将在1-2个工作日内给出答复； 微信： 我们仅为购买的用户提供一对一的服务 Mercury 通过微信。 ← 上一页 "}}